// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/agent"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/cluster"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/container"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/event"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/incidentbasicrule"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8scluster"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sconnector"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8scontainer"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sdaemonset"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sdeployment"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sevent"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8slabel"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8smetric"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8snamespace"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8snode"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sobject"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sobjecttag"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8spod"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sreplicaset"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/k8sstatefulset"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/metric"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/metricendpoint"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/metriclabel"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/metricname"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/metrictype"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/node"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/predicate"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/proces"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/process"
	"github.com/willie-lin/kubeMonitor/pkg/nextserver/database/ent/setting"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent             = "Agent"
	TypeCluster           = "Cluster"
	TypeContainer         = "Container"
	TypeEvent             = "Event"
	TypeIncidentBasicRule = "IncidentBasicRule"
	TypeK8sCluster        = "K8sCluster"
	TypeK8sConnector      = "K8sConnector"
	TypeK8sContainer      = "K8sContainer"
	TypeK8sDaemonSet      = "K8sDaemonSet"
	TypeK8sDeployment     = "K8sDeployment"
	TypeK8sEvent          = "K8sEvent"
	TypeK8sLabel          = "K8sLabel"
	TypeK8sMetric         = "K8sMetric"
	TypeK8sNamespace      = "K8sNamespace"
	TypeK8sNode           = "K8sNode"
	TypeK8sObject         = "K8sObject"
	TypeK8sObjectTag      = "K8sObjectTag"
	TypeK8sPod            = "K8sPod"
	TypeK8sReplicaSet     = "K8sReplicaSet"
	TypeK8sStatefulSet    = "K8sStatefulSet"
	TypeMetric            = "Metric"
	TypeMetricEndpoint    = "MetricEndpoint"
	TypeMetricLabel       = "MetricLabel"
	TypeMetricName        = "MetricName"
	TypeMetricType        = "MetricType"
	TypeNode              = "Node"
	TypeProces            = "Proces"
	TypeProcess           = "Process"
	TypeSetting           = "Setting"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	online        *bool
	version       *string
	ipv4          *string
	ipv6          *string
	public_ipv4   *string
	public_ipv6   *string
	last_contact  *time.Time
	disabled      *bool
	uuid          *string
	machineId     *string
	description   *string
	clusterId     *uint
	addclusterId  *uint
	clearedFields map[string]struct{}
	node          map[uint]struct{}
	removednode   map[uint]struct{}
	clearednode   bool
	owner         *uint
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Agent, error)
	predicates    []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id uint) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AgentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AgentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AgentMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetOnline sets the "online" field.
func (m *AgentMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *AgentMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ResetOnline resets all changes to the "online" field.
func (m *AgentMutation) ResetOnline() {
	m.online = nil
}

// SetVersion sets the "version" field.
func (m *AgentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentMutation) ResetVersion() {
	m.version = nil
}

// SetIpv4 sets the "ipv4" field.
func (m *AgentMutation) SetIpv4(s string) {
	m.ipv4 = &s
}

// Ipv4 returns the value of the "ipv4" field in the mutation.
func (m *AgentMutation) Ipv4() (r string, exists bool) {
	v := m.ipv4
	if v == nil {
		return
	}
	return *v, true
}

// OldIpv4 returns the old "ipv4" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIpv4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIpv4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIpv4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpv4: %w", err)
	}
	return oldValue.Ipv4, nil
}

// ResetIpv4 resets all changes to the "ipv4" field.
func (m *AgentMutation) ResetIpv4() {
	m.ipv4 = nil
}

// SetIpv6 sets the "ipv6" field.
func (m *AgentMutation) SetIpv6(s string) {
	m.ipv6 = &s
}

// Ipv6 returns the value of the "ipv6" field in the mutation.
func (m *AgentMutation) Ipv6() (r string, exists bool) {
	v := m.ipv6
	if v == nil {
		return
	}
	return *v, true
}

// OldIpv6 returns the old "ipv6" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIpv6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIpv6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIpv6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpv6: %w", err)
	}
	return oldValue.Ipv6, nil
}

// ResetIpv6 resets all changes to the "ipv6" field.
func (m *AgentMutation) ResetIpv6() {
	m.ipv6 = nil
}

// SetPublicIpv4 sets the "public_ipv4" field.
func (m *AgentMutation) SetPublicIpv4(s string) {
	m.public_ipv4 = &s
}

// PublicIpv4 returns the value of the "public_ipv4" field in the mutation.
func (m *AgentMutation) PublicIpv4() (r string, exists bool) {
	v := m.public_ipv4
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIpv4 returns the old "public_ipv4" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPublicIpv4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicIpv4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicIpv4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIpv4: %w", err)
	}
	return oldValue.PublicIpv4, nil
}

// ResetPublicIpv4 resets all changes to the "public_ipv4" field.
func (m *AgentMutation) ResetPublicIpv4() {
	m.public_ipv4 = nil
}

// SetPublicIpv6 sets the "public_ipv6" field.
func (m *AgentMutation) SetPublicIpv6(s string) {
	m.public_ipv6 = &s
}

// PublicIpv6 returns the value of the "public_ipv6" field in the mutation.
func (m *AgentMutation) PublicIpv6() (r string, exists bool) {
	v := m.public_ipv6
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIpv6 returns the old "public_ipv6" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPublicIpv6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicIpv6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicIpv6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIpv6: %w", err)
	}
	return oldValue.PublicIpv6, nil
}

// ResetPublicIpv6 resets all changes to the "public_ipv6" field.
func (m *AgentMutation) ResetPublicIpv6() {
	m.public_ipv6 = nil
}

// SetLastContact sets the "last_contact" field.
func (m *AgentMutation) SetLastContact(t time.Time) {
	m.last_contact = &t
}

// LastContact returns the value of the "last_contact" field in the mutation.
func (m *AgentMutation) LastContact() (r time.Time, exists bool) {
	v := m.last_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldLastContact returns the old "last_contact" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastContact(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastContact: %w", err)
	}
	return oldValue.LastContact, nil
}

// ResetLastContact resets all changes to the "last_contact" field.
func (m *AgentMutation) ResetLastContact() {
	m.last_contact = nil
}

// SetDisabled sets the "disabled" field.
func (m *AgentMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *AgentMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *AgentMutation) ResetDisabled() {
	m.disabled = nil
}

// SetUUID sets the "uuid" field.
func (m *AgentMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AgentMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AgentMutation) ResetUUID() {
	m.uuid = nil
}

// SetMachineId sets the "machineId" field.
func (m *AgentMutation) SetMachineId(s string) {
	m.machineId = &s
}

// MachineId returns the value of the "machineId" field in the mutation.
func (m *AgentMutation) MachineId() (r string, exists bool) {
	v := m.machineId
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineId returns the old "machineId" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMachineId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMachineId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMachineId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineId: %w", err)
	}
	return oldValue.MachineId, nil
}

// ResetMachineId resets all changes to the "machineId" field.
func (m *AgentMutation) ResetMachineId() {
	m.machineId = nil
}

// SetDescription sets the "description" field.
func (m *AgentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AgentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AgentMutation) ResetDescription() {
	m.description = nil
}

// SetClusterId sets the "clusterId" field.
func (m *AgentMutation) SetClusterId(u uint) {
	m.clusterId = &u
	m.addclusterId = nil
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *AgentMutation) ClusterId() (r uint, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// AddClusterId adds u to the "clusterId" field.
func (m *AgentMutation) AddClusterId(u uint) {
	if m.addclusterId != nil {
		*m.addclusterId += u
	} else {
		m.addclusterId = &u
	}
}

// AddedClusterId returns the value that was added to the "clusterId" field in this mutation.
func (m *AgentMutation) AddedClusterId() (r uint, exists bool) {
	v := m.addclusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *AgentMutation) ResetClusterId() {
	m.clusterId = nil
	m.addclusterId = nil
}

// AddNodeIDs adds the "node" edge to the Node entity by ids.
func (m *AgentMutation) AddNodeIDs(ids ...uint) {
	if m.node == nil {
		m.node = make(map[uint]struct{})
	}
	for i := range ids {
		m.node[ids[i]] = struct{}{}
	}
}

// ClearNode clears the "node" edge to the Node entity.
func (m *AgentMutation) ClearNode() {
	m.clearednode = true
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *AgentMutation) NodeCleared() bool {
	return m.clearednode
}

// RemoveNodeIDs removes the "node" edge to the Node entity by IDs.
func (m *AgentMutation) RemoveNodeIDs(ids ...uint) {
	if m.removednode == nil {
		m.removednode = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.node, ids[i])
		m.removednode[ids[i]] = struct{}{}
	}
}

// RemovedNode returns the removed IDs of the "node" edge to the Node entity.
func (m *AgentMutation) RemovedNodeIDs() (ids []uint) {
	for id := range m.removednode {
		ids = append(ids, id)
	}
	return
}

// NodeIDs returns the "node" edge IDs in the mutation.
func (m *AgentMutation) NodeIDs() (ids []uint) {
	for id := range m.node {
		ids = append(ids, id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *AgentMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
	m.removednode = nil
}

// SetOwnerID sets the "owner" edge to the Cluster entity by id.
func (m *AgentMutation) SetOwnerID(id uint) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Cluster entity.
func (m *AgentMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Cluster entity was cleared.
func (m *AgentMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AgentMutation) OwnerID() (id uint, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) OwnerIDs() (ids []uint) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AgentMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, agent.FieldDeletedAt)
	}
	if m.online != nil {
		fields = append(fields, agent.FieldOnline)
	}
	if m.version != nil {
		fields = append(fields, agent.FieldVersion)
	}
	if m.ipv4 != nil {
		fields = append(fields, agent.FieldIpv4)
	}
	if m.ipv6 != nil {
		fields = append(fields, agent.FieldIpv6)
	}
	if m.public_ipv4 != nil {
		fields = append(fields, agent.FieldPublicIpv4)
	}
	if m.public_ipv6 != nil {
		fields = append(fields, agent.FieldPublicIpv6)
	}
	if m.last_contact != nil {
		fields = append(fields, agent.FieldLastContact)
	}
	if m.disabled != nil {
		fields = append(fields, agent.FieldDisabled)
	}
	if m.uuid != nil {
		fields = append(fields, agent.FieldUUID)
	}
	if m.machineId != nil {
		fields = append(fields, agent.FieldMachineId)
	}
	if m.description != nil {
		fields = append(fields, agent.FieldDescription)
	}
	if m.clusterId != nil {
		fields = append(fields, agent.FieldClusterId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldDeletedAt:
		return m.DeletedAt()
	case agent.FieldOnline:
		return m.Online()
	case agent.FieldVersion:
		return m.Version()
	case agent.FieldIpv4:
		return m.Ipv4()
	case agent.FieldIpv6:
		return m.Ipv6()
	case agent.FieldPublicIpv4:
		return m.PublicIpv4()
	case agent.FieldPublicIpv6:
		return m.PublicIpv6()
	case agent.FieldLastContact:
		return m.LastContact()
	case agent.FieldDisabled:
		return m.Disabled()
	case agent.FieldUUID:
		return m.UUID()
	case agent.FieldMachineId:
		return m.MachineId()
	case agent.FieldDescription:
		return m.Description()
	case agent.FieldClusterId:
		return m.ClusterId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case agent.FieldOnline:
		return m.OldOnline(ctx)
	case agent.FieldVersion:
		return m.OldVersion(ctx)
	case agent.FieldIpv4:
		return m.OldIpv4(ctx)
	case agent.FieldIpv6:
		return m.OldIpv6(ctx)
	case agent.FieldPublicIpv4:
		return m.OldPublicIpv4(ctx)
	case agent.FieldPublicIpv6:
		return m.OldPublicIpv6(ctx)
	case agent.FieldLastContact:
		return m.OldLastContact(ctx)
	case agent.FieldDisabled:
		return m.OldDisabled(ctx)
	case agent.FieldUUID:
		return m.OldUUID(ctx)
	case agent.FieldMachineId:
		return m.OldMachineId(ctx)
	case agent.FieldDescription:
		return m.OldDescription(ctx)
	case agent.FieldClusterId:
		return m.OldClusterId(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case agent.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case agent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agent.FieldIpv4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpv4(v)
		return nil
	case agent.FieldIpv6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpv6(v)
		return nil
	case agent.FieldPublicIpv4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIpv4(v)
		return nil
	case agent.FieldPublicIpv6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIpv6(v)
		return nil
	case agent.FieldLastContact:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastContact(v)
		return nil
	case agent.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case agent.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case agent.FieldMachineId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineId(v)
		return nil
	case agent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case agent.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	var fields []string
	if m.addclusterId != nil {
		fields = append(fields, agent.FieldClusterId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldClusterId:
		return m.AddedClusterId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agent.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case agent.FieldOnline:
		m.ResetOnline()
		return nil
	case agent.FieldVersion:
		m.ResetVersion()
		return nil
	case agent.FieldIpv4:
		m.ResetIpv4()
		return nil
	case agent.FieldIpv6:
		m.ResetIpv6()
		return nil
	case agent.FieldPublicIpv4:
		m.ResetPublicIpv4()
		return nil
	case agent.FieldPublicIpv6:
		m.ResetPublicIpv6()
		return nil
	case agent.FieldLastContact:
		m.ResetLastContact()
		return nil
	case agent.FieldDisabled:
		m.ResetDisabled()
		return nil
	case agent.FieldUUID:
		m.ResetUUID()
		return nil
	case agent.FieldMachineId:
		m.ResetMachineId()
		return nil
	case agent.FieldDescription:
		m.ResetDescription()
		return nil
	case agent.FieldClusterId:
		m.ResetClusterId()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.node != nil {
		edges = append(edges, agent.EdgeNode)
	}
	if m.owner != nil {
		edges = append(edges, agent.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeNode:
		ids := make([]ent.Value, 0, len(m.node))
		for id := range m.node {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednode != nil {
		edges = append(edges, agent.EdgeNode)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeNode:
		ids := make([]ent.Value, 0, len(m.removednode))
		for id := range m.removednode {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednode {
		edges = append(edges, agent.EdgeNode)
	}
	if m.clearedowner {
		edges = append(edges, agent.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeNode:
		return m.clearednode
	case agent.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeNode:
		m.ResetNode()
		return nil
	case agent.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// ClusterMutation represents an operation that mutates the Cluster nodes in the graph.
type ClusterMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	description   *string
	disabled      *bool
	clearedFields map[string]struct{}
	agents        map[uint]struct{}
	removedagents map[uint]struct{}
	clearedagents bool
	nodes         map[uint]struct{}
	removednodes  map[uint]struct{}
	clearednodes  bool
	done          bool
	oldValue      func(context.Context) (*Cluster, error)
	predicates    []predicate.Cluster
}

var _ ent.Mutation = (*ClusterMutation)(nil)

// clusterOption allows management of the mutation configuration using functional options.
type clusterOption func(*ClusterMutation)

// newClusterMutation creates new mutation for the Cluster entity.
func newClusterMutation(c config, op Op, opts ...clusterOption) *ClusterMutation {
	m := &ClusterMutation{
		config:        c,
		op:            op,
		typ:           TypeCluster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClusterID sets the ID field of the mutation.
func withClusterID(id uint) clusterOption {
	return func(m *ClusterMutation) {
		var (
			err   error
			once  sync.Once
			value *Cluster
		)
		m.oldValue = func(ctx context.Context) (*Cluster, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cluster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCluster sets the old Cluster of the mutation.
func withCluster(node *Cluster) clusterOption {
	return func(m *ClusterMutation) {
		m.oldValue = func(context.Context) (*Cluster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClusterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClusterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cluster entities.
func (m *ClusterMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClusterMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ClusterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClusterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClusterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClusterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClusterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClusterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ClusterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ClusterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ClusterMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ClusterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClusterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClusterMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ClusterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClusterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ClusterMutation) ResetDescription() {
	m.description = nil
}

// SetDisabled sets the "disabled" field.
func (m *ClusterMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ClusterMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ClusterMutation) ResetDisabled() {
	m.disabled = nil
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *ClusterMutation) AddAgentIDs(ids ...uint) {
	if m.agents == nil {
		m.agents = make(map[uint]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *ClusterMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *ClusterMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *ClusterMutation) RemoveAgentIDs(ids ...uint) {
	if m.removedagents == nil {
		m.removedagents = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *ClusterMutation) RemovedAgentsIDs() (ids []uint) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *ClusterMutation) AgentsIDs() (ids []uint) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *ClusterMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *ClusterMutation) AddNodeIDs(ids ...uint) {
	if m.nodes == nil {
		m.nodes = make(map[uint]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *ClusterMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *ClusterMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *ClusterMutation) RemoveNodeIDs(ids ...uint) {
	if m.removednodes == nil {
		m.removednodes = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *ClusterMutation) RemovedNodesIDs() (ids []uint) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *ClusterMutation) NodesIDs() (ids []uint) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *ClusterMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the ClusterMutation builder.
func (m *ClusterMutation) Where(ps ...predicate.Cluster) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClusterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cluster).
func (m *ClusterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClusterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, cluster.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cluster.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cluster.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, cluster.FieldName)
	}
	if m.description != nil {
		fields = append(fields, cluster.FieldDescription)
	}
	if m.disabled != nil {
		fields = append(fields, cluster.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClusterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cluster.FieldCreatedAt:
		return m.CreatedAt()
	case cluster.FieldUpdatedAt:
		return m.UpdatedAt()
	case cluster.FieldDeletedAt:
		return m.DeletedAt()
	case cluster.FieldName:
		return m.Name()
	case cluster.FieldDescription:
		return m.Description()
	case cluster.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClusterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cluster.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cluster.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cluster.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cluster.FieldName:
		return m.OldName(ctx)
	case cluster.FieldDescription:
		return m.OldDescription(ctx)
	case cluster.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown Cluster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cluster.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cluster.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cluster.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cluster.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cluster.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cluster.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClusterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClusterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cluster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClusterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClusterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClusterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cluster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClusterMutation) ResetField(name string) error {
	switch name {
	case cluster.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cluster.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cluster.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cluster.FieldName:
		m.ResetName()
		return nil
	case cluster.FieldDescription:
		m.ResetDescription()
		return nil
	case cluster.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClusterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.agents != nil {
		edges = append(edges, cluster.EdgeAgents)
	}
	if m.nodes != nil {
		edges = append(edges, cluster.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClusterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cluster.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case cluster.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClusterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedagents != nil {
		edges = append(edges, cluster.EdgeAgents)
	}
	if m.removednodes != nil {
		edges = append(edges, cluster.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClusterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cluster.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case cluster.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClusterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedagents {
		edges = append(edges, cluster.EdgeAgents)
	}
	if m.clearednodes {
		edges = append(edges, cluster.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClusterMutation) EdgeCleared(name string) bool {
	switch name {
	case cluster.EdgeAgents:
		return m.clearedagents
	case cluster.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClusterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Cluster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClusterMutation) ResetEdge(name string) error {
	switch name {
	case cluster.EdgeAgents:
		m.ResetAgents()
		return nil
	case cluster.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Cluster edge %s", name)
}

// ContainerMutation represents an operation that mutates the Container nodes in the graph.
type ContainerMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	_type          *string
	containerId    *string
	name           *string
	image          *string
	info           *[]string
	clusterId      *uint
	addclusterId   *uint
	nodeId         *uint
	addnodeId      *uint
	clearedFields  map[string]struct{}
	process        map[uint]struct{}
	removedprocess map[uint]struct{}
	clearedprocess bool
	owner          *uint
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*Container, error)
	predicates     []predicate.Container
}

var _ ent.Mutation = (*ContainerMutation)(nil)

// containerOption allows management of the mutation configuration using functional options.
type containerOption func(*ContainerMutation)

// newContainerMutation creates new mutation for the Container entity.
func newContainerMutation(c config, op Op, opts ...containerOption) *ContainerMutation {
	m := &ContainerMutation{
		config:        c,
		op:            op,
		typ:           TypeContainer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContainerID sets the ID field of the mutation.
func withContainerID(id uint) containerOption {
	return func(m *ContainerMutation) {
		var (
			err   error
			once  sync.Once
			value *Container
		)
		m.oldValue = func(ctx context.Context) (*Container, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Container.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContainer sets the old Container of the mutation.
func withContainer(node *Container) containerOption {
	return func(m *ContainerMutation) {
		m.oldValue = func(context.Context) (*Container, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContainerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContainerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Container entities.
func (m *ContainerMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContainerMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ContainerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContainerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContainerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContainerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContainerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContainerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContainerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContainerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContainerMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *ContainerMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContainerMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContainerMutation) ResetType() {
	m._type = nil
}

// SetContainerId sets the "containerId" field.
func (m *ContainerMutation) SetContainerId(s string) {
	m.containerId = &s
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *ContainerMutation) ContainerId() (r string, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldContainerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *ContainerMutation) ResetContainerId() {
	m.containerId = nil
}

// SetName sets the "name" field.
func (m *ContainerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContainerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContainerMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *ContainerMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ContainerMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ContainerMutation) ResetImage() {
	m.image = nil
}

// SetInfo sets the "info" field.
func (m *ContainerMutation) SetInfo(s []string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *ContainerMutation) Info() (r []string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldInfo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *ContainerMutation) ResetInfo() {
	m.info = nil
}

// SetClusterId sets the "clusterId" field.
func (m *ContainerMutation) SetClusterId(u uint) {
	m.clusterId = &u
	m.addclusterId = nil
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *ContainerMutation) ClusterId() (r uint, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// AddClusterId adds u to the "clusterId" field.
func (m *ContainerMutation) AddClusterId(u uint) {
	if m.addclusterId != nil {
		*m.addclusterId += u
	} else {
		m.addclusterId = &u
	}
}

// AddedClusterId returns the value that was added to the "clusterId" field in this mutation.
func (m *ContainerMutation) AddedClusterId() (r uint, exists bool) {
	v := m.addclusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *ContainerMutation) ResetClusterId() {
	m.clusterId = nil
	m.addclusterId = nil
}

// SetNodeId sets the "nodeId" field.
func (m *ContainerMutation) SetNodeId(u uint) {
	m.nodeId = &u
	m.addnodeId = nil
}

// NodeId returns the value of the "nodeId" field in the mutation.
func (m *ContainerMutation) NodeId() (r uint, exists bool) {
	v := m.nodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeId returns the old "nodeId" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldNodeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeId: %w", err)
	}
	return oldValue.NodeId, nil
}

// AddNodeId adds u to the "nodeId" field.
func (m *ContainerMutation) AddNodeId(u uint) {
	if m.addnodeId != nil {
		*m.addnodeId += u
	} else {
		m.addnodeId = &u
	}
}

// AddedNodeId returns the value that was added to the "nodeId" field in this mutation.
func (m *ContainerMutation) AddedNodeId() (r uint, exists bool) {
	v := m.addnodeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeId resets all changes to the "nodeId" field.
func (m *ContainerMutation) ResetNodeId() {
	m.nodeId = nil
	m.addnodeId = nil
}

// AddProcesIDs adds the "process" edge to the Proces entity by ids.
func (m *ContainerMutation) AddProcesIDs(ids ...uint) {
	if m.process == nil {
		m.process = make(map[uint]struct{})
	}
	for i := range ids {
		m.process[ids[i]] = struct{}{}
	}
}

// ClearProcess clears the "process" edge to the Proces entity.
func (m *ContainerMutation) ClearProcess() {
	m.clearedprocess = true
}

// ProcessCleared reports if the "process" edge to the Proces entity was cleared.
func (m *ContainerMutation) ProcessCleared() bool {
	return m.clearedprocess
}

// RemoveProcesIDs removes the "process" edge to the Proces entity by IDs.
func (m *ContainerMutation) RemoveProcesIDs(ids ...uint) {
	if m.removedprocess == nil {
		m.removedprocess = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.process, ids[i])
		m.removedprocess[ids[i]] = struct{}{}
	}
}

// RemovedProcess returns the removed IDs of the "process" edge to the Proces entity.
func (m *ContainerMutation) RemovedProcessIDs() (ids []uint) {
	for id := range m.removedprocess {
		ids = append(ids, id)
	}
	return
}

// ProcessIDs returns the "process" edge IDs in the mutation.
func (m *ContainerMutation) ProcessIDs() (ids []uint) {
	for id := range m.process {
		ids = append(ids, id)
	}
	return
}

// ResetProcess resets all changes to the "process" edge.
func (m *ContainerMutation) ResetProcess() {
	m.process = nil
	m.clearedprocess = false
	m.removedprocess = nil
}

// SetOwnerID sets the "owner" edge to the Node entity by id.
func (m *ContainerMutation) SetOwnerID(id uint) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Node entity.
func (m *ContainerMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Node entity was cleared.
func (m *ContainerMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ContainerMutation) OwnerID() (id uint, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ContainerMutation) OwnerIDs() (ids []uint) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ContainerMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ContainerMutation builder.
func (m *ContainerMutation) Where(ps ...predicate.Container) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContainerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Container).
func (m *ContainerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContainerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, container.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, container.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, container.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, container.FieldType)
	}
	if m.containerId != nil {
		fields = append(fields, container.FieldContainerId)
	}
	if m.name != nil {
		fields = append(fields, container.FieldName)
	}
	if m.image != nil {
		fields = append(fields, container.FieldImage)
	}
	if m.info != nil {
		fields = append(fields, container.FieldInfo)
	}
	if m.clusterId != nil {
		fields = append(fields, container.FieldClusterId)
	}
	if m.nodeId != nil {
		fields = append(fields, container.FieldNodeId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContainerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case container.FieldCreatedAt:
		return m.CreatedAt()
	case container.FieldUpdatedAt:
		return m.UpdatedAt()
	case container.FieldDeletedAt:
		return m.DeletedAt()
	case container.FieldType:
		return m.GetType()
	case container.FieldContainerId:
		return m.ContainerId()
	case container.FieldName:
		return m.Name()
	case container.FieldImage:
		return m.Image()
	case container.FieldInfo:
		return m.Info()
	case container.FieldClusterId:
		return m.ClusterId()
	case container.FieldNodeId:
		return m.NodeId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContainerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case container.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case container.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case container.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case container.FieldType:
		return m.OldType(ctx)
	case container.FieldContainerId:
		return m.OldContainerId(ctx)
	case container.FieldName:
		return m.OldName(ctx)
	case container.FieldImage:
		return m.OldImage(ctx)
	case container.FieldInfo:
		return m.OldInfo(ctx)
	case container.FieldClusterId:
		return m.OldClusterId(ctx)
	case container.FieldNodeId:
		return m.OldNodeId(ctx)
	}
	return nil, fmt.Errorf("unknown Container field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContainerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case container.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case container.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case container.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case container.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case container.FieldContainerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	case container.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case container.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case container.FieldInfo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case container.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	case container.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeId(v)
		return nil
	}
	return fmt.Errorf("unknown Container field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContainerMutation) AddedFields() []string {
	var fields []string
	if m.addclusterId != nil {
		fields = append(fields, container.FieldClusterId)
	}
	if m.addnodeId != nil {
		fields = append(fields, container.FieldNodeId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContainerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case container.FieldClusterId:
		return m.AddedClusterId()
	case container.FieldNodeId:
		return m.AddedNodeId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContainerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case container.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClusterId(v)
		return nil
	case container.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeId(v)
		return nil
	}
	return fmt.Errorf("unknown Container numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContainerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContainerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContainerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Container nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContainerMutation) ResetField(name string) error {
	switch name {
	case container.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case container.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case container.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case container.FieldType:
		m.ResetType()
		return nil
	case container.FieldContainerId:
		m.ResetContainerId()
		return nil
	case container.FieldName:
		m.ResetName()
		return nil
	case container.FieldImage:
		m.ResetImage()
		return nil
	case container.FieldInfo:
		m.ResetInfo()
		return nil
	case container.FieldClusterId:
		m.ResetClusterId()
		return nil
	case container.FieldNodeId:
		m.ResetNodeId()
		return nil
	}
	return fmt.Errorf("unknown Container field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContainerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.process != nil {
		edges = append(edges, container.EdgeProcess)
	}
	if m.owner != nil {
		edges = append(edges, container.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContainerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case container.EdgeProcess:
		ids := make([]ent.Value, 0, len(m.process))
		for id := range m.process {
			ids = append(ids, id)
		}
		return ids
	case container.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContainerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprocess != nil {
		edges = append(edges, container.EdgeProcess)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContainerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case container.EdgeProcess:
		ids := make([]ent.Value, 0, len(m.removedprocess))
		for id := range m.removedprocess {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContainerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprocess {
		edges = append(edges, container.EdgeProcess)
	}
	if m.clearedowner {
		edges = append(edges, container.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContainerMutation) EdgeCleared(name string) bool {
	switch name {
	case container.EdgeProcess:
		return m.clearedprocess
	case container.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContainerMutation) ClearEdge(name string) error {
	switch name {
	case container.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Container unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContainerMutation) ResetEdge(name string) error {
	switch name {
	case container.EdgeProcess:
		m.ResetProcess()
		return nil
	case container.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Container edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	ts                            *time.Time
	value                         *float64
	addvalue                      *float64
	acked                         *bool
	ackedTs                       *time.Time
	endpointId                    *uint
	addendpointId                 *uint
	typeId                        *uint
	addtypeId                     *uint
	nameId                        *uint
	addnameId                     *uint
	labelId                       *uint
	addlabelId                    *uint
	clusterId                     *uint
	addclusterId                  *uint
	agentId                       *uint
	addagentId                    *uint
	nodeId                        *uint
	addnodeId                     *uint
	procesId                      *uint
	addprocesId                   *uint
	containerId                   *uint
	addcontainerId                *uint
	podId                         *uint
	addpodId                      *uint
	clearedFields                 map[string]struct{}
	_MetricName_events            *uint
	cleared_MetricName_events     bool
	_MetricLabel_events           *uint
	cleared_MetricLabel_events    bool
	_MetricEndpoint_events        *uint
	cleared_MetricEndpoint_events bool
	done                          bool
	oldValue                      func(context.Context) (*Event, error)
	predicates                    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTs sets the "ts" field.
func (m *EventMutation) SetTs(t time.Time) {
	m.ts = &t
}

// Ts returns the value of the "ts" field in the mutation.
func (m *EventMutation) Ts() (r time.Time, exists bool) {
	v := m.ts
	if v == nil {
		return
	}
	return *v, true
}

// OldTs returns the old "ts" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTs(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTs: %w", err)
	}
	return oldValue.Ts, nil
}

// ResetTs resets all changes to the "ts" field.
func (m *EventMutation) ResetTs() {
	m.ts = nil
}

// SetValue sets the "value" field.
func (m *EventMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *EventMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *EventMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *EventMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *EventMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetAcked sets the "acked" field.
func (m *EventMutation) SetAcked(b bool) {
	m.acked = &b
}

// Acked returns the value of the "acked" field in the mutation.
func (m *EventMutation) Acked() (r bool, exists bool) {
	v := m.acked
	if v == nil {
		return
	}
	return *v, true
}

// OldAcked returns the old "acked" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAcked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAcked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAcked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcked: %w", err)
	}
	return oldValue.Acked, nil
}

// ResetAcked resets all changes to the "acked" field.
func (m *EventMutation) ResetAcked() {
	m.acked = nil
}

// SetAckedTs sets the "ackedTs" field.
func (m *EventMutation) SetAckedTs(t time.Time) {
	m.ackedTs = &t
}

// AckedTs returns the value of the "ackedTs" field in the mutation.
func (m *EventMutation) AckedTs() (r time.Time, exists bool) {
	v := m.ackedTs
	if v == nil {
		return
	}
	return *v, true
}

// OldAckedTs returns the old "ackedTs" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAckedTs(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAckedTs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAckedTs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAckedTs: %w", err)
	}
	return oldValue.AckedTs, nil
}

// ResetAckedTs resets all changes to the "ackedTs" field.
func (m *EventMutation) ResetAckedTs() {
	m.ackedTs = nil
}

// SetEndpointId sets the "endpointId" field.
func (m *EventMutation) SetEndpointId(u uint) {
	m.endpointId = &u
	m.addendpointId = nil
}

// EndpointId returns the value of the "endpointId" field in the mutation.
func (m *EventMutation) EndpointId() (r uint, exists bool) {
	v := m.endpointId
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointId returns the old "endpointId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndpointId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndpointId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndpointId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointId: %w", err)
	}
	return oldValue.EndpointId, nil
}

// AddEndpointId adds u to the "endpointId" field.
func (m *EventMutation) AddEndpointId(u uint) {
	if m.addendpointId != nil {
		*m.addendpointId += u
	} else {
		m.addendpointId = &u
	}
}

// AddedEndpointId returns the value that was added to the "endpointId" field in this mutation.
func (m *EventMutation) AddedEndpointId() (r uint, exists bool) {
	v := m.addendpointId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndpointId resets all changes to the "endpointId" field.
func (m *EventMutation) ResetEndpointId() {
	m.endpointId = nil
	m.addendpointId = nil
}

// SetTypeId sets the "typeId" field.
func (m *EventMutation) SetTypeId(u uint) {
	m.typeId = &u
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *EventMutation) TypeId() (r uint, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTypeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds u to the "typeId" field.
func (m *EventMutation) AddTypeId(u uint) {
	if m.addtypeId != nil {
		*m.addtypeId += u
	} else {
		m.addtypeId = &u
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *EventMutation) AddedTypeId() (r uint, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *EventMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// SetNameId sets the "nameId" field.
func (m *EventMutation) SetNameId(u uint) {
	m.nameId = &u
	m.addnameId = nil
}

// NameId returns the value of the "nameId" field in the mutation.
func (m *EventMutation) NameId() (r uint, exists bool) {
	v := m.nameId
	if v == nil {
		return
	}
	return *v, true
}

// OldNameId returns the old "nameId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldNameId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNameId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNameId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameId: %w", err)
	}
	return oldValue.NameId, nil
}

// AddNameId adds u to the "nameId" field.
func (m *EventMutation) AddNameId(u uint) {
	if m.addnameId != nil {
		*m.addnameId += u
	} else {
		m.addnameId = &u
	}
}

// AddedNameId returns the value that was added to the "nameId" field in this mutation.
func (m *EventMutation) AddedNameId() (r uint, exists bool) {
	v := m.addnameId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNameId resets all changes to the "nameId" field.
func (m *EventMutation) ResetNameId() {
	m.nameId = nil
	m.addnameId = nil
}

// SetLabelId sets the "labelId" field.
func (m *EventMutation) SetLabelId(u uint) {
	m.labelId = &u
	m.addlabelId = nil
}

// LabelId returns the value of the "labelId" field in the mutation.
func (m *EventMutation) LabelId() (r uint, exists bool) {
	v := m.labelId
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelId returns the old "labelId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLabelId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelId: %w", err)
	}
	return oldValue.LabelId, nil
}

// AddLabelId adds u to the "labelId" field.
func (m *EventMutation) AddLabelId(u uint) {
	if m.addlabelId != nil {
		*m.addlabelId += u
	} else {
		m.addlabelId = &u
	}
}

// AddedLabelId returns the value that was added to the "labelId" field in this mutation.
func (m *EventMutation) AddedLabelId() (r uint, exists bool) {
	v := m.addlabelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetLabelId resets all changes to the "labelId" field.
func (m *EventMutation) ResetLabelId() {
	m.labelId = nil
	m.addlabelId = nil
}

// SetClusterId sets the "clusterId" field.
func (m *EventMutation) SetClusterId(u uint) {
	m.clusterId = &u
	m.addclusterId = nil
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *EventMutation) ClusterId() (r uint, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// AddClusterId adds u to the "clusterId" field.
func (m *EventMutation) AddClusterId(u uint) {
	if m.addclusterId != nil {
		*m.addclusterId += u
	} else {
		m.addclusterId = &u
	}
}

// AddedClusterId returns the value that was added to the "clusterId" field in this mutation.
func (m *EventMutation) AddedClusterId() (r uint, exists bool) {
	v := m.addclusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *EventMutation) ResetClusterId() {
	m.clusterId = nil
	m.addclusterId = nil
}

// SetAgentId sets the "agentId" field.
func (m *EventMutation) SetAgentId(u uint) {
	m.agentId = &u
	m.addagentId = nil
}

// AgentId returns the value of the "agentId" field in the mutation.
func (m *EventMutation) AgentId() (r uint, exists bool) {
	v := m.agentId
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentId returns the old "agentId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAgentId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentId: %w", err)
	}
	return oldValue.AgentId, nil
}

// AddAgentId adds u to the "agentId" field.
func (m *EventMutation) AddAgentId(u uint) {
	if m.addagentId != nil {
		*m.addagentId += u
	} else {
		m.addagentId = &u
	}
}

// AddedAgentId returns the value that was added to the "agentId" field in this mutation.
func (m *EventMutation) AddedAgentId() (r uint, exists bool) {
	v := m.addagentId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgentId resets all changes to the "agentId" field.
func (m *EventMutation) ResetAgentId() {
	m.agentId = nil
	m.addagentId = nil
}

// SetNodeId sets the "nodeId" field.
func (m *EventMutation) SetNodeId(u uint) {
	m.nodeId = &u
	m.addnodeId = nil
}

// NodeId returns the value of the "nodeId" field in the mutation.
func (m *EventMutation) NodeId() (r uint, exists bool) {
	v := m.nodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeId returns the old "nodeId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldNodeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeId: %w", err)
	}
	return oldValue.NodeId, nil
}

// AddNodeId adds u to the "nodeId" field.
func (m *EventMutation) AddNodeId(u uint) {
	if m.addnodeId != nil {
		*m.addnodeId += u
	} else {
		m.addnodeId = &u
	}
}

// AddedNodeId returns the value that was added to the "nodeId" field in this mutation.
func (m *EventMutation) AddedNodeId() (r uint, exists bool) {
	v := m.addnodeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeId resets all changes to the "nodeId" field.
func (m *EventMutation) ResetNodeId() {
	m.nodeId = nil
	m.addnodeId = nil
}

// SetProcesId sets the "procesId" field.
func (m *EventMutation) SetProcesId(u uint) {
	m.procesId = &u
	m.addprocesId = nil
}

// ProcesId returns the value of the "procesId" field in the mutation.
func (m *EventMutation) ProcesId() (r uint, exists bool) {
	v := m.procesId
	if v == nil {
		return
	}
	return *v, true
}

// OldProcesId returns the old "procesId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldProcesId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProcesId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProcesId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcesId: %w", err)
	}
	return oldValue.ProcesId, nil
}

// AddProcesId adds u to the "procesId" field.
func (m *EventMutation) AddProcesId(u uint) {
	if m.addprocesId != nil {
		*m.addprocesId += u
	} else {
		m.addprocesId = &u
	}
}

// AddedProcesId returns the value that was added to the "procesId" field in this mutation.
func (m *EventMutation) AddedProcesId() (r uint, exists bool) {
	v := m.addprocesId
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcesId resets all changes to the "procesId" field.
func (m *EventMutation) ResetProcesId() {
	m.procesId = nil
	m.addprocesId = nil
}

// SetContainerId sets the "containerId" field.
func (m *EventMutation) SetContainerId(u uint) {
	m.containerId = &u
	m.addcontainerId = nil
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *EventMutation) ContainerId() (r uint, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldContainerId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// AddContainerId adds u to the "containerId" field.
func (m *EventMutation) AddContainerId(u uint) {
	if m.addcontainerId != nil {
		*m.addcontainerId += u
	} else {
		m.addcontainerId = &u
	}
}

// AddedContainerId returns the value that was added to the "containerId" field in this mutation.
func (m *EventMutation) AddedContainerId() (r uint, exists bool) {
	v := m.addcontainerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *EventMutation) ResetContainerId() {
	m.containerId = nil
	m.addcontainerId = nil
}

// SetPodId sets the "podId" field.
func (m *EventMutation) SetPodId(u uint) {
	m.podId = &u
	m.addpodId = nil
}

// PodId returns the value of the "podId" field in the mutation.
func (m *EventMutation) PodId() (r uint, exists bool) {
	v := m.podId
	if v == nil {
		return
	}
	return *v, true
}

// OldPodId returns the old "podId" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldPodId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPodId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPodId: %w", err)
	}
	return oldValue.PodId, nil
}

// AddPodId adds u to the "podId" field.
func (m *EventMutation) AddPodId(u uint) {
	if m.addpodId != nil {
		*m.addpodId += u
	} else {
		m.addpodId = &u
	}
}

// AddedPodId returns the value that was added to the "podId" field in this mutation.
func (m *EventMutation) AddedPodId() (r uint, exists bool) {
	v := m.addpodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPodId resets all changes to the "podId" field.
func (m *EventMutation) ResetPodId() {
	m.podId = nil
	m.addpodId = nil
}

// SetMetricNameEventsID sets the "MetricName_events" edge to the MetricName entity by id.
func (m *EventMutation) SetMetricNameEventsID(id uint) {
	m._MetricName_events = &id
}

// ClearMetricNameEvents clears the "MetricName_events" edge to the MetricName entity.
func (m *EventMutation) ClearMetricNameEvents() {
	m.cleared_MetricName_events = true
}

// MetricNameEventsCleared reports if the "MetricName_events" edge to the MetricName entity was cleared.
func (m *EventMutation) MetricNameEventsCleared() bool {
	return m.cleared_MetricName_events
}

// MetricNameEventsID returns the "MetricName_events" edge ID in the mutation.
func (m *EventMutation) MetricNameEventsID() (id uint, exists bool) {
	if m._MetricName_events != nil {
		return *m._MetricName_events, true
	}
	return
}

// MetricNameEventsIDs returns the "MetricName_events" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricNameEventsID instead. It exists only for internal usage by the builders.
func (m *EventMutation) MetricNameEventsIDs() (ids []uint) {
	if id := m._MetricName_events; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetricNameEvents resets all changes to the "MetricName_events" edge.
func (m *EventMutation) ResetMetricNameEvents() {
	m._MetricName_events = nil
	m.cleared_MetricName_events = false
}

// SetMetricLabelEventsID sets the "MetricLabel_events" edge to the MetricLabel entity by id.
func (m *EventMutation) SetMetricLabelEventsID(id uint) {
	m._MetricLabel_events = &id
}

// ClearMetricLabelEvents clears the "MetricLabel_events" edge to the MetricLabel entity.
func (m *EventMutation) ClearMetricLabelEvents() {
	m.cleared_MetricLabel_events = true
}

// MetricLabelEventsCleared reports if the "MetricLabel_events" edge to the MetricLabel entity was cleared.
func (m *EventMutation) MetricLabelEventsCleared() bool {
	return m.cleared_MetricLabel_events
}

// MetricLabelEventsID returns the "MetricLabel_events" edge ID in the mutation.
func (m *EventMutation) MetricLabelEventsID() (id uint, exists bool) {
	if m._MetricLabel_events != nil {
		return *m._MetricLabel_events, true
	}
	return
}

// MetricLabelEventsIDs returns the "MetricLabel_events" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricLabelEventsID instead. It exists only for internal usage by the builders.
func (m *EventMutation) MetricLabelEventsIDs() (ids []uint) {
	if id := m._MetricLabel_events; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetricLabelEvents resets all changes to the "MetricLabel_events" edge.
func (m *EventMutation) ResetMetricLabelEvents() {
	m._MetricLabel_events = nil
	m.cleared_MetricLabel_events = false
}

// SetMetricEndpointEventsID sets the "MetricEndpoint_events" edge to the MetricEndpoint entity by id.
func (m *EventMutation) SetMetricEndpointEventsID(id uint) {
	m._MetricEndpoint_events = &id
}

// ClearMetricEndpointEvents clears the "MetricEndpoint_events" edge to the MetricEndpoint entity.
func (m *EventMutation) ClearMetricEndpointEvents() {
	m.cleared_MetricEndpoint_events = true
}

// MetricEndpointEventsCleared reports if the "MetricEndpoint_events" edge to the MetricEndpoint entity was cleared.
func (m *EventMutation) MetricEndpointEventsCleared() bool {
	return m.cleared_MetricEndpoint_events
}

// MetricEndpointEventsID returns the "MetricEndpoint_events" edge ID in the mutation.
func (m *EventMutation) MetricEndpointEventsID() (id uint, exists bool) {
	if m._MetricEndpoint_events != nil {
		return *m._MetricEndpoint_events, true
	}
	return
}

// MetricEndpointEventsIDs returns the "MetricEndpoint_events" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricEndpointEventsID instead. It exists only for internal usage by the builders.
func (m *EventMutation) MetricEndpointEventsIDs() (ids []uint) {
	if id := m._MetricEndpoint_events; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetricEndpointEvents resets all changes to the "MetricEndpoint_events" edge.
func (m *EventMutation) ResetMetricEndpointEvents() {
	m._MetricEndpoint_events = nil
	m.cleared_MetricEndpoint_events = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.ts != nil {
		fields = append(fields, event.FieldTs)
	}
	if m.value != nil {
		fields = append(fields, event.FieldValue)
	}
	if m.acked != nil {
		fields = append(fields, event.FieldAcked)
	}
	if m.ackedTs != nil {
		fields = append(fields, event.FieldAckedTs)
	}
	if m.endpointId != nil {
		fields = append(fields, event.FieldEndpointId)
	}
	if m.typeId != nil {
		fields = append(fields, event.FieldTypeId)
	}
	if m.nameId != nil {
		fields = append(fields, event.FieldNameId)
	}
	if m.labelId != nil {
		fields = append(fields, event.FieldLabelId)
	}
	if m.clusterId != nil {
		fields = append(fields, event.FieldClusterId)
	}
	if m.agentId != nil {
		fields = append(fields, event.FieldAgentId)
	}
	if m.nodeId != nil {
		fields = append(fields, event.FieldNodeId)
	}
	if m.procesId != nil {
		fields = append(fields, event.FieldProcesId)
	}
	if m.containerId != nil {
		fields = append(fields, event.FieldContainerId)
	}
	if m.podId != nil {
		fields = append(fields, event.FieldPodId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldTs:
		return m.Ts()
	case event.FieldValue:
		return m.Value()
	case event.FieldAcked:
		return m.Acked()
	case event.FieldAckedTs:
		return m.AckedTs()
	case event.FieldEndpointId:
		return m.EndpointId()
	case event.FieldTypeId:
		return m.TypeId()
	case event.FieldNameId:
		return m.NameId()
	case event.FieldLabelId:
		return m.LabelId()
	case event.FieldClusterId:
		return m.ClusterId()
	case event.FieldAgentId:
		return m.AgentId()
	case event.FieldNodeId:
		return m.NodeId()
	case event.FieldProcesId:
		return m.ProcesId()
	case event.FieldContainerId:
		return m.ContainerId()
	case event.FieldPodId:
		return m.PodId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldTs:
		return m.OldTs(ctx)
	case event.FieldValue:
		return m.OldValue(ctx)
	case event.FieldAcked:
		return m.OldAcked(ctx)
	case event.FieldAckedTs:
		return m.OldAckedTs(ctx)
	case event.FieldEndpointId:
		return m.OldEndpointId(ctx)
	case event.FieldTypeId:
		return m.OldTypeId(ctx)
	case event.FieldNameId:
		return m.OldNameId(ctx)
	case event.FieldLabelId:
		return m.OldLabelId(ctx)
	case event.FieldClusterId:
		return m.OldClusterId(ctx)
	case event.FieldAgentId:
		return m.OldAgentId(ctx)
	case event.FieldNodeId:
		return m.OldNodeId(ctx)
	case event.FieldProcesId:
		return m.OldProcesId(ctx)
	case event.FieldContainerId:
		return m.OldContainerId(ctx)
	case event.FieldPodId:
		return m.OldPodId(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldTs:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTs(v)
		return nil
	case event.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case event.FieldAcked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcked(v)
		return nil
	case event.FieldAckedTs:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAckedTs(v)
		return nil
	case event.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointId(v)
		return nil
	case event.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case event.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameId(v)
		return nil
	case event.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelId(v)
		return nil
	case event.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	case event.FieldAgentId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentId(v)
		return nil
	case event.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeId(v)
		return nil
	case event.FieldProcesId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcesId(v)
		return nil
	case event.FieldContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	case event.FieldPodId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPodId(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, event.FieldValue)
	}
	if m.addendpointId != nil {
		fields = append(fields, event.FieldEndpointId)
	}
	if m.addtypeId != nil {
		fields = append(fields, event.FieldTypeId)
	}
	if m.addnameId != nil {
		fields = append(fields, event.FieldNameId)
	}
	if m.addlabelId != nil {
		fields = append(fields, event.FieldLabelId)
	}
	if m.addclusterId != nil {
		fields = append(fields, event.FieldClusterId)
	}
	if m.addagentId != nil {
		fields = append(fields, event.FieldAgentId)
	}
	if m.addnodeId != nil {
		fields = append(fields, event.FieldNodeId)
	}
	if m.addprocesId != nil {
		fields = append(fields, event.FieldProcesId)
	}
	if m.addcontainerId != nil {
		fields = append(fields, event.FieldContainerId)
	}
	if m.addpodId != nil {
		fields = append(fields, event.FieldPodId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldValue:
		return m.AddedValue()
	case event.FieldEndpointId:
		return m.AddedEndpointId()
	case event.FieldTypeId:
		return m.AddedTypeId()
	case event.FieldNameId:
		return m.AddedNameId()
	case event.FieldLabelId:
		return m.AddedLabelId()
	case event.FieldClusterId:
		return m.AddedClusterId()
	case event.FieldAgentId:
		return m.AddedAgentId()
	case event.FieldNodeId:
		return m.AddedNodeId()
	case event.FieldProcesId:
		return m.AddedProcesId()
	case event.FieldContainerId:
		return m.AddedContainerId()
	case event.FieldPodId:
		return m.AddedPodId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case event.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndpointId(v)
		return nil
	case event.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case event.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNameId(v)
		return nil
	case event.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLabelId(v)
		return nil
	case event.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClusterId(v)
		return nil
	case event.FieldAgentId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgentId(v)
		return nil
	case event.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeId(v)
		return nil
	case event.FieldProcesId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcesId(v)
		return nil
	case event.FieldContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContainerId(v)
		return nil
	case event.FieldPodId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPodId(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldTs:
		m.ResetTs()
		return nil
	case event.FieldValue:
		m.ResetValue()
		return nil
	case event.FieldAcked:
		m.ResetAcked()
		return nil
	case event.FieldAckedTs:
		m.ResetAckedTs()
		return nil
	case event.FieldEndpointId:
		m.ResetEndpointId()
		return nil
	case event.FieldTypeId:
		m.ResetTypeId()
		return nil
	case event.FieldNameId:
		m.ResetNameId()
		return nil
	case event.FieldLabelId:
		m.ResetLabelId()
		return nil
	case event.FieldClusterId:
		m.ResetClusterId()
		return nil
	case event.FieldAgentId:
		m.ResetAgentId()
		return nil
	case event.FieldNodeId:
		m.ResetNodeId()
		return nil
	case event.FieldProcesId:
		m.ResetProcesId()
		return nil
	case event.FieldContainerId:
		m.ResetContainerId()
		return nil
	case event.FieldPodId:
		m.ResetPodId()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._MetricName_events != nil {
		edges = append(edges, event.EdgeMetricNameEvents)
	}
	if m._MetricLabel_events != nil {
		edges = append(edges, event.EdgeMetricLabelEvents)
	}
	if m._MetricEndpoint_events != nil {
		edges = append(edges, event.EdgeMetricEndpointEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeMetricNameEvents:
		if id := m._MetricName_events; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeMetricLabelEvents:
		if id := m._MetricLabel_events; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeMetricEndpointEvents:
		if id := m._MetricEndpoint_events; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_MetricName_events {
		edges = append(edges, event.EdgeMetricNameEvents)
	}
	if m.cleared_MetricLabel_events {
		edges = append(edges, event.EdgeMetricLabelEvents)
	}
	if m.cleared_MetricEndpoint_events {
		edges = append(edges, event.EdgeMetricEndpointEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeMetricNameEvents:
		return m.cleared_MetricName_events
	case event.EdgeMetricLabelEvents:
		return m.cleared_MetricLabel_events
	case event.EdgeMetricEndpointEvents:
		return m.cleared_MetricEndpoint_events
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeMetricNameEvents:
		m.ClearMetricNameEvents()
		return nil
	case event.EdgeMetricLabelEvents:
		m.ClearMetricLabelEvents()
		return nil
	case event.EdgeMetricEndpointEvents:
		m.ClearMetricEndpointEvents()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeMetricNameEvents:
		m.ResetMetricNameEvents()
		return nil
	case event.EdgeMetricLabelEvents:
		m.ResetMetricLabelEvents()
		return nil
	case event.EdgeMetricEndpointEvents:
		m.ResetMetricEndpointEvents()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// IncidentBasicRuleMutation represents an operation that mutates the IncidentBasicRule nodes in the graph.
type IncidentBasicRuleMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	_Description  *string
	query         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IncidentBasicRule, error)
	predicates    []predicate.IncidentBasicRule
}

var _ ent.Mutation = (*IncidentBasicRuleMutation)(nil)

// incidentbasicruleOption allows management of the mutation configuration using functional options.
type incidentbasicruleOption func(*IncidentBasicRuleMutation)

// newIncidentBasicRuleMutation creates new mutation for the IncidentBasicRule entity.
func newIncidentBasicRuleMutation(c config, op Op, opts ...incidentbasicruleOption) *IncidentBasicRuleMutation {
	m := &IncidentBasicRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentBasicRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentBasicRuleID sets the ID field of the mutation.
func withIncidentBasicRuleID(id uint) incidentbasicruleOption {
	return func(m *IncidentBasicRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentBasicRule
		)
		m.oldValue = func(ctx context.Context) (*IncidentBasicRule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentBasicRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentBasicRule sets the old IncidentBasicRule of the mutation.
func withIncidentBasicRule(node *IncidentBasicRule) incidentbasicruleOption {
	return func(m *IncidentBasicRuleMutation) {
		m.oldValue = func(context.Context) (*IncidentBasicRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentBasicRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentBasicRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentBasicRule entities.
func (m *IncidentBasicRuleMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentBasicRuleMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentBasicRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentBasicRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentBasicRule entity.
// If the IncidentBasicRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentBasicRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentBasicRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentBasicRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentBasicRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentBasicRule entity.
// If the IncidentBasicRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentBasicRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentBasicRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IncidentBasicRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IncidentBasicRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IncidentBasicRule entity.
// If the IncidentBasicRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentBasicRuleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IncidentBasicRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *IncidentBasicRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentBasicRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentBasicRule entity.
// If the IncidentBasicRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentBasicRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentBasicRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "Description" field.
func (m *IncidentBasicRuleMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *IncidentBasicRuleMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the IncidentBasicRule entity.
// If the IncidentBasicRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentBasicRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *IncidentBasicRuleMutation) ResetDescription() {
	m._Description = nil
}

// SetQuery sets the "query" field.
func (m *IncidentBasicRuleMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *IncidentBasicRuleMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the IncidentBasicRule entity.
// If the IncidentBasicRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentBasicRuleMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ResetQuery resets all changes to the "query" field.
func (m *IncidentBasicRuleMutation) ResetQuery() {
	m.query = nil
}

// Where appends a list predicates to the IncidentBasicRuleMutation builder.
func (m *IncidentBasicRuleMutation) Where(ps ...predicate.IncidentBasicRule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IncidentBasicRuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (IncidentBasicRule).
func (m *IncidentBasicRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentBasicRuleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, incidentbasicrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentbasicrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, incidentbasicrule.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, incidentbasicrule.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, incidentbasicrule.FieldDescription)
	}
	if m.query != nil {
		fields = append(fields, incidentbasicrule.FieldQuery)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentBasicRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentbasicrule.FieldCreatedAt:
		return m.CreatedAt()
	case incidentbasicrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case incidentbasicrule.FieldDeletedAt:
		return m.DeletedAt()
	case incidentbasicrule.FieldName:
		return m.Name()
	case incidentbasicrule.FieldDescription:
		return m.Description()
	case incidentbasicrule.FieldQuery:
		return m.Query()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentBasicRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentbasicrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentbasicrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case incidentbasicrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case incidentbasicrule.FieldName:
		return m.OldName(ctx)
	case incidentbasicrule.FieldDescription:
		return m.OldDescription(ctx)
	case incidentbasicrule.FieldQuery:
		return m.OldQuery(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentBasicRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentBasicRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentbasicrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentbasicrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case incidentbasicrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case incidentbasicrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incidentbasicrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentbasicrule.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentBasicRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentBasicRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentBasicRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentBasicRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentBasicRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentBasicRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentBasicRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentBasicRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentBasicRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentBasicRuleMutation) ResetField(name string) error {
	switch name {
	case incidentbasicrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentbasicrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case incidentbasicrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case incidentbasicrule.FieldName:
		m.ResetName()
		return nil
	case incidentbasicrule.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentbasicrule.FieldQuery:
		m.ResetQuery()
		return nil
	}
	return fmt.Errorf("unknown IncidentBasicRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentBasicRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentBasicRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentBasicRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentBasicRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentBasicRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentBasicRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentBasicRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IncidentBasicRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentBasicRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IncidentBasicRule edge %s", name)
}

// K8sClusterMutation represents an operation that mutates the K8sCluster nodes in the graph.
type K8sClusterMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	agentClusterId    *uint
	addagentClusterId *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sCluster, error)
	predicates        []predicate.K8sCluster
}

var _ ent.Mutation = (*K8sClusterMutation)(nil)

// k8sclusterOption allows management of the mutation configuration using functional options.
type k8sclusterOption func(*K8sClusterMutation)

// newK8sClusterMutation creates new mutation for the K8sCluster entity.
func newK8sClusterMutation(c config, op Op, opts ...k8sclusterOption) *K8sClusterMutation {
	m := &K8sClusterMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sCluster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sClusterID sets the ID field of the mutation.
func withK8sClusterID(id uint) k8sclusterOption {
	return func(m *K8sClusterMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sCluster
		)
		m.oldValue = func(ctx context.Context) (*K8sCluster, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sCluster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sCluster sets the old K8sCluster of the mutation.
func withK8sCluster(node *K8sCluster) k8sclusterOption {
	return func(m *K8sClusterMutation) {
		m.oldValue = func(context.Context) (*K8sCluster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sClusterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sClusterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sCluster entities.
func (m *K8sClusterMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sClusterMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sClusterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sClusterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sCluster entity.
// If the K8sCluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sClusterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sClusterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sClusterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sClusterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sCluster entity.
// If the K8sCluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sClusterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sClusterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sClusterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sClusterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sCluster entity.
// If the K8sCluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sClusterMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sClusterMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sClusterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sClusterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sCluster entity.
// If the K8sCluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sClusterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sClusterMutation) ResetName() {
	m.name = nil
}

// SetAgentClusterId sets the "agentClusterId" field.
func (m *K8sClusterMutation) SetAgentClusterId(u uint) {
	m.agentClusterId = &u
	m.addagentClusterId = nil
}

// AgentClusterId returns the value of the "agentClusterId" field in the mutation.
func (m *K8sClusterMutation) AgentClusterId() (r uint, exists bool) {
	v := m.agentClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentClusterId returns the old "agentClusterId" field's value of the K8sCluster entity.
// If the K8sCluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sClusterMutation) OldAgentClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentClusterId: %w", err)
	}
	return oldValue.AgentClusterId, nil
}

// AddAgentClusterId adds u to the "agentClusterId" field.
func (m *K8sClusterMutation) AddAgentClusterId(u uint) {
	if m.addagentClusterId != nil {
		*m.addagentClusterId += u
	} else {
		m.addagentClusterId = &u
	}
}

// AddedAgentClusterId returns the value that was added to the "agentClusterId" field in this mutation.
func (m *K8sClusterMutation) AddedAgentClusterId() (r uint, exists bool) {
	v := m.addagentClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgentClusterId resets all changes to the "agentClusterId" field.
func (m *K8sClusterMutation) ResetAgentClusterId() {
	m.agentClusterId = nil
	m.addagentClusterId = nil
}

// Where appends a list predicates to the K8sClusterMutation builder.
func (m *K8sClusterMutation) Where(ps ...predicate.K8sCluster) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sClusterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sCluster).
func (m *K8sClusterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sClusterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, k8scluster.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8scluster.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8scluster.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8scluster.FieldName)
	}
	if m.agentClusterId != nil {
		fields = append(fields, k8scluster.FieldAgentClusterId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sClusterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8scluster.FieldCreatedAt:
		return m.CreatedAt()
	case k8scluster.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8scluster.FieldDeletedAt:
		return m.DeletedAt()
	case k8scluster.FieldName:
		return m.Name()
	case k8scluster.FieldAgentClusterId:
		return m.AgentClusterId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sClusterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8scluster.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8scluster.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8scluster.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8scluster.FieldName:
		return m.OldName(ctx)
	case k8scluster.FieldAgentClusterId:
		return m.OldAgentClusterId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sCluster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sClusterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8scluster.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8scluster.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8scluster.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8scluster.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8scluster.FieldAgentClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sCluster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sClusterMutation) AddedFields() []string {
	var fields []string
	if m.addagentClusterId != nil {
		fields = append(fields, k8scluster.FieldAgentClusterId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sClusterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8scluster.FieldAgentClusterId:
		return m.AddedAgentClusterId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sClusterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8scluster.FieldAgentClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgentClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sCluster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sClusterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sClusterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sClusterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sCluster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sClusterMutation) ResetField(name string) error {
	switch name {
	case k8scluster.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8scluster.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8scluster.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8scluster.FieldName:
		m.ResetName()
		return nil
	case k8scluster.FieldAgentClusterId:
		m.ResetAgentClusterId()
		return nil
	}
	return fmt.Errorf("unknown K8sCluster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sClusterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sClusterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sClusterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sClusterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sClusterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sClusterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sClusterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sCluster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sClusterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sCluster edge %s", name)
}

// K8sConnectorMutation represents an operation that mutates the K8sConnector nodes in the graph.
type K8sConnectorMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	status        *string
	method        *string
	inCluster     *bool
	bearerToken   *string
	kubeConfig    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*K8sConnector, error)
	predicates    []predicate.K8sConnector
}

var _ ent.Mutation = (*K8sConnectorMutation)(nil)

// k8sconnectorOption allows management of the mutation configuration using functional options.
type k8sconnectorOption func(*K8sConnectorMutation)

// newK8sConnectorMutation creates new mutation for the K8sConnector entity.
func newK8sConnectorMutation(c config, op Op, opts ...k8sconnectorOption) *K8sConnectorMutation {
	m := &K8sConnectorMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sConnector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sConnectorID sets the ID field of the mutation.
func withK8sConnectorID(id uint) k8sconnectorOption {
	return func(m *K8sConnectorMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sConnector
		)
		m.oldValue = func(ctx context.Context) (*K8sConnector, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sConnector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sConnector sets the old K8sConnector of the mutation.
func withK8sConnector(node *K8sConnector) k8sconnectorOption {
	return func(m *K8sConnectorMutation) {
		m.oldValue = func(context.Context) (*K8sConnector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sConnectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sConnectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sConnector entities.
func (m *K8sConnectorMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sConnectorMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sConnectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sConnectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sConnectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sConnectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sConnectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sConnectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sConnectorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sConnectorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sConnectorMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sConnectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sConnectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sConnectorMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *K8sConnectorMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *K8sConnectorMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *K8sConnectorMutation) ResetStatus() {
	m.status = nil
}

// SetMethod sets the "method" field.
func (m *K8sConnectorMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *K8sConnectorMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *K8sConnectorMutation) ResetMethod() {
	m.method = nil
}

// SetInCluster sets the "inCluster" field.
func (m *K8sConnectorMutation) SetInCluster(b bool) {
	m.inCluster = &b
}

// InCluster returns the value of the "inCluster" field in the mutation.
func (m *K8sConnectorMutation) InCluster() (r bool, exists bool) {
	v := m.inCluster
	if v == nil {
		return
	}
	return *v, true
}

// OldInCluster returns the old "inCluster" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldInCluster(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInCluster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInCluster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInCluster: %w", err)
	}
	return oldValue.InCluster, nil
}

// ResetInCluster resets all changes to the "inCluster" field.
func (m *K8sConnectorMutation) ResetInCluster() {
	m.inCluster = nil
}

// SetBearerToken sets the "bearerToken" field.
func (m *K8sConnectorMutation) SetBearerToken(s string) {
	m.bearerToken = &s
}

// BearerToken returns the value of the "bearerToken" field in the mutation.
func (m *K8sConnectorMutation) BearerToken() (r string, exists bool) {
	v := m.bearerToken
	if v == nil {
		return
	}
	return *v, true
}

// OldBearerToken returns the old "bearerToken" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldBearerToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBearerToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBearerToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBearerToken: %w", err)
	}
	return oldValue.BearerToken, nil
}

// ResetBearerToken resets all changes to the "bearerToken" field.
func (m *K8sConnectorMutation) ResetBearerToken() {
	m.bearerToken = nil
}

// SetKubeConfig sets the "kubeConfig" field.
func (m *K8sConnectorMutation) SetKubeConfig(s string) {
	m.kubeConfig = &s
}

// KubeConfig returns the value of the "kubeConfig" field in the mutation.
func (m *K8sConnectorMutation) KubeConfig() (r string, exists bool) {
	v := m.kubeConfig
	if v == nil {
		return
	}
	return *v, true
}

// OldKubeConfig returns the old "kubeConfig" field's value of the K8sConnector entity.
// If the K8sConnector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sConnectorMutation) OldKubeConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKubeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKubeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKubeConfig: %w", err)
	}
	return oldValue.KubeConfig, nil
}

// ResetKubeConfig resets all changes to the "kubeConfig" field.
func (m *K8sConnectorMutation) ResetKubeConfig() {
	m.kubeConfig = nil
}

// Where appends a list predicates to the K8sConnectorMutation builder.
func (m *K8sConnectorMutation) Where(ps ...predicate.K8sConnector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sConnectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sConnector).
func (m *K8sConnectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sConnectorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, k8sconnector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sconnector.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sconnector.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8sconnector.FieldName)
	}
	if m.status != nil {
		fields = append(fields, k8sconnector.FieldStatus)
	}
	if m.method != nil {
		fields = append(fields, k8sconnector.FieldMethod)
	}
	if m.inCluster != nil {
		fields = append(fields, k8sconnector.FieldInCluster)
	}
	if m.bearerToken != nil {
		fields = append(fields, k8sconnector.FieldBearerToken)
	}
	if m.kubeConfig != nil {
		fields = append(fields, k8sconnector.FieldKubeConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sConnectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sconnector.FieldCreatedAt:
		return m.CreatedAt()
	case k8sconnector.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sconnector.FieldDeletedAt:
		return m.DeletedAt()
	case k8sconnector.FieldName:
		return m.Name()
	case k8sconnector.FieldStatus:
		return m.Status()
	case k8sconnector.FieldMethod:
		return m.Method()
	case k8sconnector.FieldInCluster:
		return m.InCluster()
	case k8sconnector.FieldBearerToken:
		return m.BearerToken()
	case k8sconnector.FieldKubeConfig:
		return m.KubeConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sconnector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sconnector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sconnector.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sconnector.FieldName:
		return m.OldName(ctx)
	case k8sconnector.FieldStatus:
		return m.OldStatus(ctx)
	case k8sconnector.FieldMethod:
		return m.OldMethod(ctx)
	case k8sconnector.FieldInCluster:
		return m.OldInCluster(ctx)
	case k8sconnector.FieldBearerToken:
		return m.OldBearerToken(ctx)
	case k8sconnector.FieldKubeConfig:
		return m.OldKubeConfig(ctx)
	}
	return nil, fmt.Errorf("unknown K8sConnector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sConnectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sconnector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sconnector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sconnector.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sconnector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8sconnector.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case k8sconnector.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case k8sconnector.FieldInCluster:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInCluster(v)
		return nil
	case k8sconnector.FieldBearerToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBearerToken(v)
		return nil
	case k8sconnector.FieldKubeConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKubeConfig(v)
		return nil
	}
	return fmt.Errorf("unknown K8sConnector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sConnectorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sConnectorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sConnectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown K8sConnector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sConnectorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sConnectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sConnectorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sConnector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sConnectorMutation) ResetField(name string) error {
	switch name {
	case k8sconnector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sconnector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sconnector.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sconnector.FieldName:
		m.ResetName()
		return nil
	case k8sconnector.FieldStatus:
		m.ResetStatus()
		return nil
	case k8sconnector.FieldMethod:
		m.ResetMethod()
		return nil
	case k8sconnector.FieldInCluster:
		m.ResetInCluster()
		return nil
	case k8sconnector.FieldBearerToken:
		m.ResetBearerToken()
		return nil
	case k8sconnector.FieldKubeConfig:
		m.ResetKubeConfig()
		return nil
	}
	return fmt.Errorf("unknown K8sConnector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sConnectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sConnectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sConnectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sConnectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sConnectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sConnectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sConnectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sConnector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sConnectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sConnector edge %s", name)
}

// K8sContainerMutation represents an operation that mutates the K8sContainer nodes in the graph.
type K8sContainerMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	image             *string
	containerType     *string
	containerId       *string
	k8sClusterId      *uint
	addk8sClusterId   *uint
	k8sNamespaceId    *uint
	addk8sNamespaceId *uint
	_K8sPodId         *uint
	add_K8sPodId      *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sContainer, error)
	predicates        []predicate.K8sContainer
}

var _ ent.Mutation = (*K8sContainerMutation)(nil)

// k8scontainerOption allows management of the mutation configuration using functional options.
type k8scontainerOption func(*K8sContainerMutation)

// newK8sContainerMutation creates new mutation for the K8sContainer entity.
func newK8sContainerMutation(c config, op Op, opts ...k8scontainerOption) *K8sContainerMutation {
	m := &K8sContainerMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sContainer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sContainerID sets the ID field of the mutation.
func withK8sContainerID(id uint) k8scontainerOption {
	return func(m *K8sContainerMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sContainer
		)
		m.oldValue = func(ctx context.Context) (*K8sContainer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sContainer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sContainer sets the old K8sContainer of the mutation.
func withK8sContainer(node *K8sContainer) k8scontainerOption {
	return func(m *K8sContainerMutation) {
		m.oldValue = func(context.Context) (*K8sContainer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sContainerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sContainerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sContainer entities.
func (m *K8sContainerMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sContainerMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sContainerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sContainerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sContainerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sContainerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sContainerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sContainerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sContainerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sContainerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sContainerMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sContainerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sContainerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sContainerMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *K8sContainerMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *K8sContainerMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *K8sContainerMutation) ResetImage() {
	m.image = nil
}

// SetContainerType sets the "containerType" field.
func (m *K8sContainerMutation) SetContainerType(s string) {
	m.containerType = &s
}

// ContainerType returns the value of the "containerType" field in the mutation.
func (m *K8sContainerMutation) ContainerType() (r string, exists bool) {
	v := m.containerType
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerType returns the old "containerType" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldContainerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerType: %w", err)
	}
	return oldValue.ContainerType, nil
}

// ResetContainerType resets all changes to the "containerType" field.
func (m *K8sContainerMutation) ResetContainerType() {
	m.containerType = nil
}

// SetContainerId sets the "containerId" field.
func (m *K8sContainerMutation) SetContainerId(s string) {
	m.containerId = &s
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *K8sContainerMutation) ContainerId() (r string, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldContainerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *K8sContainerMutation) ResetContainerId() {
	m.containerId = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sContainerMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sContainerMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sContainerMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sContainerMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sContainerMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sContainerMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sContainerMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sContainerMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sContainerMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sContainerMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sPodId sets the "K8sPodId" field.
func (m *K8sContainerMutation) SetK8sPodId(u uint) {
	m._K8sPodId = &u
	m.add_K8sPodId = nil
}

// K8sPodId returns the value of the "K8sPodId" field in the mutation.
func (m *K8sContainerMutation) K8sPodId() (r uint, exists bool) {
	v := m._K8sPodId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sPodId returns the old "K8sPodId" field's value of the K8sContainer entity.
// If the K8sContainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sContainerMutation) OldK8sPodId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sPodId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sPodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sPodId: %w", err)
	}
	return oldValue.K8sPodId, nil
}

// AddK8sPodId adds u to the "K8sPodId" field.
func (m *K8sContainerMutation) AddK8sPodId(u uint) {
	if m.add_K8sPodId != nil {
		*m.add_K8sPodId += u
	} else {
		m.add_K8sPodId = &u
	}
}

// AddedK8sPodId returns the value that was added to the "K8sPodId" field in this mutation.
func (m *K8sContainerMutation) AddedK8sPodId() (r uint, exists bool) {
	v := m.add_K8sPodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sPodId resets all changes to the "K8sPodId" field.
func (m *K8sContainerMutation) ResetK8sPodId() {
	m._K8sPodId = nil
	m.add_K8sPodId = nil
}

// Where appends a list predicates to the K8sContainerMutation builder.
func (m *K8sContainerMutation) Where(ps ...predicate.K8sContainer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sContainerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sContainer).
func (m *K8sContainerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sContainerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, k8scontainer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8scontainer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8scontainer.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8scontainer.FieldName)
	}
	if m.image != nil {
		fields = append(fields, k8scontainer.FieldImage)
	}
	if m.containerType != nil {
		fields = append(fields, k8scontainer.FieldContainerType)
	}
	if m.containerId != nil {
		fields = append(fields, k8scontainer.FieldContainerId)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8scontainer.FieldK8sClusterId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8scontainer.FieldK8sNamespaceId)
	}
	if m._K8sPodId != nil {
		fields = append(fields, k8scontainer.FieldK8sPodId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sContainerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8scontainer.FieldCreatedAt:
		return m.CreatedAt()
	case k8scontainer.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8scontainer.FieldDeletedAt:
		return m.DeletedAt()
	case k8scontainer.FieldName:
		return m.Name()
	case k8scontainer.FieldImage:
		return m.Image()
	case k8scontainer.FieldContainerType:
		return m.ContainerType()
	case k8scontainer.FieldContainerId:
		return m.ContainerId()
	case k8scontainer.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8scontainer.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8scontainer.FieldK8sPodId:
		return m.K8sPodId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sContainerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8scontainer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8scontainer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8scontainer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8scontainer.FieldName:
		return m.OldName(ctx)
	case k8scontainer.FieldImage:
		return m.OldImage(ctx)
	case k8scontainer.FieldContainerType:
		return m.OldContainerType(ctx)
	case k8scontainer.FieldContainerId:
		return m.OldContainerId(ctx)
	case k8scontainer.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8scontainer.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8scontainer.FieldK8sPodId:
		return m.OldK8sPodId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sContainer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sContainerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8scontainer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8scontainer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8scontainer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8scontainer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8scontainer.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case k8scontainer.FieldContainerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerType(v)
		return nil
	case k8scontainer.FieldContainerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	case k8scontainer.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8scontainer.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8scontainer.FieldK8sPodId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sPodId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sContainer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sContainerMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8scontainer.FieldK8sClusterId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8scontainer.FieldK8sNamespaceId)
	}
	if m.add_K8sPodId != nil {
		fields = append(fields, k8scontainer.FieldK8sPodId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sContainerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8scontainer.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8scontainer.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8scontainer.FieldK8sPodId:
		return m.AddedK8sPodId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sContainerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8scontainer.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8scontainer.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8scontainer.FieldK8sPodId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sPodId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sContainer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sContainerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sContainerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sContainerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sContainer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sContainerMutation) ResetField(name string) error {
	switch name {
	case k8scontainer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8scontainer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8scontainer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8scontainer.FieldName:
		m.ResetName()
		return nil
	case k8scontainer.FieldImage:
		m.ResetImage()
		return nil
	case k8scontainer.FieldContainerType:
		m.ResetContainerType()
		return nil
	case k8scontainer.FieldContainerId:
		m.ResetContainerId()
		return nil
	case k8scontainer.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8scontainer.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8scontainer.FieldK8sPodId:
		m.ResetK8sPodId()
		return nil
	}
	return fmt.Errorf("unknown K8sContainer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sContainerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sContainerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sContainerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sContainerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sContainerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sContainerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sContainerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sContainer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sContainerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sContainer edge %s", name)
}

// K8sDaemonSetMutation represents an operation that mutates the K8sDaemonSet nodes in the graph.
type K8sDaemonSetMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	k8sClusterId      *uint
	addk8sClusterId   *uint
	k8sNamespaceId    *uint
	addk8sNamespaceId *uint
	k8sObjectId       *uint
	addk8sObjectId    *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sDaemonSet, error)
	predicates        []predicate.K8sDaemonSet
}

var _ ent.Mutation = (*K8sDaemonSetMutation)(nil)

// k8sdaemonsetOption allows management of the mutation configuration using functional options.
type k8sdaemonsetOption func(*K8sDaemonSetMutation)

// newK8sDaemonSetMutation creates new mutation for the K8sDaemonSet entity.
func newK8sDaemonSetMutation(c config, op Op, opts ...k8sdaemonsetOption) *K8sDaemonSetMutation {
	m := &K8sDaemonSetMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sDaemonSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sDaemonSetID sets the ID field of the mutation.
func withK8sDaemonSetID(id uint) k8sdaemonsetOption {
	return func(m *K8sDaemonSetMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sDaemonSet
		)
		m.oldValue = func(ctx context.Context) (*K8sDaemonSet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sDaemonSet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sDaemonSet sets the old K8sDaemonSet of the mutation.
func withK8sDaemonSet(node *K8sDaemonSet) k8sdaemonsetOption {
	return func(m *K8sDaemonSetMutation) {
		m.oldValue = func(context.Context) (*K8sDaemonSet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sDaemonSetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sDaemonSetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sDaemonSet entities.
func (m *K8sDaemonSetMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sDaemonSetMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sDaemonSetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sDaemonSetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sDaemonSetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sDaemonSetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sDaemonSetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sDaemonSetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sDaemonSetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sDaemonSetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sDaemonSetMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sDaemonSetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sDaemonSetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sDaemonSetMutation) ResetName() {
	m.name = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sDaemonSetMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sDaemonSetMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sDaemonSetMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sDaemonSetMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sDaemonSetMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sDaemonSetMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sDaemonSetMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sDaemonSetMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sDaemonSetMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sDaemonSetMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sDaemonSetMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sDaemonSetMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sDaemonSet entity.
// If the K8sDaemonSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDaemonSetMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sDaemonSetMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sDaemonSetMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sDaemonSetMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sDaemonSetMutation builder.
func (m *K8sDaemonSetMutation) Where(ps ...predicate.K8sDaemonSet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sDaemonSetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sDaemonSet).
func (m *K8sDaemonSetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sDaemonSetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, k8sdaemonset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sdaemonset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sdaemonset.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8sdaemonset.FieldName)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8sdaemonset.FieldK8sClusterId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8sdaemonset.FieldK8sNamespaceId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8sdaemonset.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sDaemonSetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sdaemonset.FieldCreatedAt:
		return m.CreatedAt()
	case k8sdaemonset.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sdaemonset.FieldDeletedAt:
		return m.DeletedAt()
	case k8sdaemonset.FieldName:
		return m.Name()
	case k8sdaemonset.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8sdaemonset.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8sdaemonset.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sDaemonSetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sdaemonset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sdaemonset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sdaemonset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sdaemonset.FieldName:
		return m.OldName(ctx)
	case k8sdaemonset.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8sdaemonset.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8sdaemonset.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sDaemonSet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sDaemonSetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sdaemonset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sdaemonset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sdaemonset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sdaemonset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8sdaemonset.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8sdaemonset.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8sdaemonset.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sDaemonSet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sDaemonSetMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8sdaemonset.FieldK8sClusterId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8sdaemonset.FieldK8sNamespaceId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8sdaemonset.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sDaemonSetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sdaemonset.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8sdaemonset.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8sdaemonset.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sDaemonSetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sdaemonset.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8sdaemonset.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8sdaemonset.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sDaemonSet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sDaemonSetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sDaemonSetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sDaemonSetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sDaemonSet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sDaemonSetMutation) ResetField(name string) error {
	switch name {
	case k8sdaemonset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sdaemonset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sdaemonset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sdaemonset.FieldName:
		m.ResetName()
		return nil
	case k8sdaemonset.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8sdaemonset.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8sdaemonset.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sDaemonSet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sDaemonSetMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sDaemonSetMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sDaemonSetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sDaemonSetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sDaemonSetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sDaemonSetMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sDaemonSetMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sDaemonSet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sDaemonSetMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sDaemonSet edge %s", name)
}

// K8sDeploymentMutation represents an operation that mutates the K8sDeployment nodes in the graph.
type K8sDeploymentMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	k8sClusterId      *uint
	addk8sClusterId   *uint
	k8sNamespaceId    *uint
	addk8sNamespaceId *uint
	k8sObjectId       *uint
	addk8sObjectId    *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sDeployment, error)
	predicates        []predicate.K8sDeployment
}

var _ ent.Mutation = (*K8sDeploymentMutation)(nil)

// k8sdeploymentOption allows management of the mutation configuration using functional options.
type k8sdeploymentOption func(*K8sDeploymentMutation)

// newK8sDeploymentMutation creates new mutation for the K8sDeployment entity.
func newK8sDeploymentMutation(c config, op Op, opts ...k8sdeploymentOption) *K8sDeploymentMutation {
	m := &K8sDeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sDeploymentID sets the ID field of the mutation.
func withK8sDeploymentID(id uint) k8sdeploymentOption {
	return func(m *K8sDeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sDeployment
		)
		m.oldValue = func(ctx context.Context) (*K8sDeployment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sDeployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sDeployment sets the old K8sDeployment of the mutation.
func withK8sDeployment(node *K8sDeployment) k8sdeploymentOption {
	return func(m *K8sDeploymentMutation) {
		m.oldValue = func(context.Context) (*K8sDeployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sDeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sDeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sDeployment entities.
func (m *K8sDeploymentMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sDeploymentMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sDeploymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sDeploymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sDeploymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sDeploymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sDeploymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sDeploymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sDeploymentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sDeploymentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sDeploymentMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sDeploymentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sDeploymentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sDeploymentMutation) ResetName() {
	m.name = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sDeploymentMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sDeploymentMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sDeploymentMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sDeploymentMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sDeploymentMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sDeploymentMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sDeploymentMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sDeploymentMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sDeploymentMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sDeploymentMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sDeploymentMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sDeploymentMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sDeployment entity.
// If the K8sDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sDeploymentMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sDeploymentMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sDeploymentMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sDeploymentMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sDeploymentMutation builder.
func (m *K8sDeploymentMutation) Where(ps ...predicate.K8sDeployment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sDeploymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sDeployment).
func (m *K8sDeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sDeploymentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, k8sdeployment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sdeployment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sdeployment.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8sdeployment.FieldName)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8sdeployment.FieldK8sClusterId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8sdeployment.FieldK8sNamespaceId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8sdeployment.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sDeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sdeployment.FieldCreatedAt:
		return m.CreatedAt()
	case k8sdeployment.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sdeployment.FieldDeletedAt:
		return m.DeletedAt()
	case k8sdeployment.FieldName:
		return m.Name()
	case k8sdeployment.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8sdeployment.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8sdeployment.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sDeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sdeployment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sdeployment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sdeployment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sdeployment.FieldName:
		return m.OldName(ctx)
	case k8sdeployment.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8sdeployment.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8sdeployment.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sDeployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sDeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sdeployment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sdeployment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sdeployment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sdeployment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8sdeployment.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8sdeployment.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8sdeployment.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sDeployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sDeploymentMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8sdeployment.FieldK8sClusterId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8sdeployment.FieldK8sNamespaceId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8sdeployment.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sDeploymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sdeployment.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8sdeployment.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8sdeployment.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sDeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sdeployment.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8sdeployment.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8sdeployment.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sDeployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sDeploymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sDeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sDeploymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sDeployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sDeploymentMutation) ResetField(name string) error {
	switch name {
	case k8sdeployment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sdeployment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sdeployment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sdeployment.FieldName:
		m.ResetName()
		return nil
	case k8sdeployment.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8sdeployment.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8sdeployment.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sDeployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sDeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sDeploymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sDeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sDeploymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sDeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sDeploymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sDeploymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sDeployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sDeploymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sDeployment edge %s", name)
}

// K8sEventMutation represents an operation that mutates the K8sEvent nodes in the graph.
type K8sEventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	ts             *time.Time
	value          *float64
	addvalue       *float64
	endpointId     *uint
	addendpointId  *uint
	typeId         *uint
	addtypeId      *uint
	nameId         *uint
	addnameId      *uint
	labelId        *uint
	addlabelId     *uint
	clusterId      *uint
	addclusterId   *uint
	namespaceId    *uint
	addnamespaceId *uint
	nodeId         *uint
	addnodeId      *uint
	containerId    *uint
	addcontainerId *uint
	podId          *uint
	addpodId       *uint
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*K8sEvent, error)
	predicates     []predicate.K8sEvent
}

var _ ent.Mutation = (*K8sEventMutation)(nil)

// k8seventOption allows management of the mutation configuration using functional options.
type k8seventOption func(*K8sEventMutation)

// newK8sEventMutation creates new mutation for the K8sEvent entity.
func newK8sEventMutation(c config, op Op, opts ...k8seventOption) *K8sEventMutation {
	m := &K8sEventMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sEventID sets the ID field of the mutation.
func withK8sEventID(id int) k8seventOption {
	return func(m *K8sEventMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sEvent
		)
		m.oldValue = func(ctx context.Context) (*K8sEvent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sEvent sets the old K8sEvent of the mutation.
func withK8sEvent(node *K8sEvent) k8seventOption {
	return func(m *K8sEventMutation) {
		m.oldValue = func(context.Context) (*K8sEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTs sets the "ts" field.
func (m *K8sEventMutation) SetTs(t time.Time) {
	m.ts = &t
}

// Ts returns the value of the "ts" field in the mutation.
func (m *K8sEventMutation) Ts() (r time.Time, exists bool) {
	v := m.ts
	if v == nil {
		return
	}
	return *v, true
}

// OldTs returns the old "ts" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldTs(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTs: %w", err)
	}
	return oldValue.Ts, nil
}

// ResetTs resets all changes to the "ts" field.
func (m *K8sEventMutation) ResetTs() {
	m.ts = nil
}

// SetValue sets the "value" field.
func (m *K8sEventMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *K8sEventMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *K8sEventMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *K8sEventMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *K8sEventMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetEndpointId sets the "endpointId" field.
func (m *K8sEventMutation) SetEndpointId(u uint) {
	m.endpointId = &u
	m.addendpointId = nil
}

// EndpointId returns the value of the "endpointId" field in the mutation.
func (m *K8sEventMutation) EndpointId() (r uint, exists bool) {
	v := m.endpointId
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointId returns the old "endpointId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldEndpointId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndpointId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndpointId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointId: %w", err)
	}
	return oldValue.EndpointId, nil
}

// AddEndpointId adds u to the "endpointId" field.
func (m *K8sEventMutation) AddEndpointId(u uint) {
	if m.addendpointId != nil {
		*m.addendpointId += u
	} else {
		m.addendpointId = &u
	}
}

// AddedEndpointId returns the value that was added to the "endpointId" field in this mutation.
func (m *K8sEventMutation) AddedEndpointId() (r uint, exists bool) {
	v := m.addendpointId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndpointId resets all changes to the "endpointId" field.
func (m *K8sEventMutation) ResetEndpointId() {
	m.endpointId = nil
	m.addendpointId = nil
}

// SetTypeId sets the "typeId" field.
func (m *K8sEventMutation) SetTypeId(u uint) {
	m.typeId = &u
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *K8sEventMutation) TypeId() (r uint, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldTypeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds u to the "typeId" field.
func (m *K8sEventMutation) AddTypeId(u uint) {
	if m.addtypeId != nil {
		*m.addtypeId += u
	} else {
		m.addtypeId = &u
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *K8sEventMutation) AddedTypeId() (r uint, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *K8sEventMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// SetNameId sets the "nameId" field.
func (m *K8sEventMutation) SetNameId(u uint) {
	m.nameId = &u
	m.addnameId = nil
}

// NameId returns the value of the "nameId" field in the mutation.
func (m *K8sEventMutation) NameId() (r uint, exists bool) {
	v := m.nameId
	if v == nil {
		return
	}
	return *v, true
}

// OldNameId returns the old "nameId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldNameId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNameId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNameId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameId: %w", err)
	}
	return oldValue.NameId, nil
}

// AddNameId adds u to the "nameId" field.
func (m *K8sEventMutation) AddNameId(u uint) {
	if m.addnameId != nil {
		*m.addnameId += u
	} else {
		m.addnameId = &u
	}
}

// AddedNameId returns the value that was added to the "nameId" field in this mutation.
func (m *K8sEventMutation) AddedNameId() (r uint, exists bool) {
	v := m.addnameId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNameId resets all changes to the "nameId" field.
func (m *K8sEventMutation) ResetNameId() {
	m.nameId = nil
	m.addnameId = nil
}

// SetLabelId sets the "labelId" field.
func (m *K8sEventMutation) SetLabelId(u uint) {
	m.labelId = &u
	m.addlabelId = nil
}

// LabelId returns the value of the "labelId" field in the mutation.
func (m *K8sEventMutation) LabelId() (r uint, exists bool) {
	v := m.labelId
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelId returns the old "labelId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldLabelId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelId: %w", err)
	}
	return oldValue.LabelId, nil
}

// AddLabelId adds u to the "labelId" field.
func (m *K8sEventMutation) AddLabelId(u uint) {
	if m.addlabelId != nil {
		*m.addlabelId += u
	} else {
		m.addlabelId = &u
	}
}

// AddedLabelId returns the value that was added to the "labelId" field in this mutation.
func (m *K8sEventMutation) AddedLabelId() (r uint, exists bool) {
	v := m.addlabelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetLabelId resets all changes to the "labelId" field.
func (m *K8sEventMutation) ResetLabelId() {
	m.labelId = nil
	m.addlabelId = nil
}

// SetClusterId sets the "clusterId" field.
func (m *K8sEventMutation) SetClusterId(u uint) {
	m.clusterId = &u
	m.addclusterId = nil
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *K8sEventMutation) ClusterId() (r uint, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// AddClusterId adds u to the "clusterId" field.
func (m *K8sEventMutation) AddClusterId(u uint) {
	if m.addclusterId != nil {
		*m.addclusterId += u
	} else {
		m.addclusterId = &u
	}
}

// AddedClusterId returns the value that was added to the "clusterId" field in this mutation.
func (m *K8sEventMutation) AddedClusterId() (r uint, exists bool) {
	v := m.addclusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *K8sEventMutation) ResetClusterId() {
	m.clusterId = nil
	m.addclusterId = nil
}

// SetNamespaceId sets the "namespaceId" field.
func (m *K8sEventMutation) SetNamespaceId(u uint) {
	m.namespaceId = &u
	m.addnamespaceId = nil
}

// NamespaceId returns the value of the "namespaceId" field in the mutation.
func (m *K8sEventMutation) NamespaceId() (r uint, exists bool) {
	v := m.namespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceId returns the old "namespaceId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceId: %w", err)
	}
	return oldValue.NamespaceId, nil
}

// AddNamespaceId adds u to the "namespaceId" field.
func (m *K8sEventMutation) AddNamespaceId(u uint) {
	if m.addnamespaceId != nil {
		*m.addnamespaceId += u
	} else {
		m.addnamespaceId = &u
	}
}

// AddedNamespaceId returns the value that was added to the "namespaceId" field in this mutation.
func (m *K8sEventMutation) AddedNamespaceId() (r uint, exists bool) {
	v := m.addnamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNamespaceId resets all changes to the "namespaceId" field.
func (m *K8sEventMutation) ResetNamespaceId() {
	m.namespaceId = nil
	m.addnamespaceId = nil
}

// SetNodeId sets the "nodeId" field.
func (m *K8sEventMutation) SetNodeId(u uint) {
	m.nodeId = &u
	m.addnodeId = nil
}

// NodeId returns the value of the "nodeId" field in the mutation.
func (m *K8sEventMutation) NodeId() (r uint, exists bool) {
	v := m.nodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeId returns the old "nodeId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldNodeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeId: %w", err)
	}
	return oldValue.NodeId, nil
}

// AddNodeId adds u to the "nodeId" field.
func (m *K8sEventMutation) AddNodeId(u uint) {
	if m.addnodeId != nil {
		*m.addnodeId += u
	} else {
		m.addnodeId = &u
	}
}

// AddedNodeId returns the value that was added to the "nodeId" field in this mutation.
func (m *K8sEventMutation) AddedNodeId() (r uint, exists bool) {
	v := m.addnodeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeId resets all changes to the "nodeId" field.
func (m *K8sEventMutation) ResetNodeId() {
	m.nodeId = nil
	m.addnodeId = nil
}

// SetContainerId sets the "containerId" field.
func (m *K8sEventMutation) SetContainerId(u uint) {
	m.containerId = &u
	m.addcontainerId = nil
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *K8sEventMutation) ContainerId() (r uint, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldContainerId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// AddContainerId adds u to the "containerId" field.
func (m *K8sEventMutation) AddContainerId(u uint) {
	if m.addcontainerId != nil {
		*m.addcontainerId += u
	} else {
		m.addcontainerId = &u
	}
}

// AddedContainerId returns the value that was added to the "containerId" field in this mutation.
func (m *K8sEventMutation) AddedContainerId() (r uint, exists bool) {
	v := m.addcontainerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *K8sEventMutation) ResetContainerId() {
	m.containerId = nil
	m.addcontainerId = nil
}

// SetPodId sets the "podId" field.
func (m *K8sEventMutation) SetPodId(u uint) {
	m.podId = &u
	m.addpodId = nil
}

// PodId returns the value of the "podId" field in the mutation.
func (m *K8sEventMutation) PodId() (r uint, exists bool) {
	v := m.podId
	if v == nil {
		return
	}
	return *v, true
}

// OldPodId returns the old "podId" field's value of the K8sEvent entity.
// If the K8sEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sEventMutation) OldPodId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPodId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPodId: %w", err)
	}
	return oldValue.PodId, nil
}

// AddPodId adds u to the "podId" field.
func (m *K8sEventMutation) AddPodId(u uint) {
	if m.addpodId != nil {
		*m.addpodId += u
	} else {
		m.addpodId = &u
	}
}

// AddedPodId returns the value that was added to the "podId" field in this mutation.
func (m *K8sEventMutation) AddedPodId() (r uint, exists bool) {
	v := m.addpodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPodId resets all changes to the "podId" field.
func (m *K8sEventMutation) ResetPodId() {
	m.podId = nil
	m.addpodId = nil
}

// Where appends a list predicates to the K8sEventMutation builder.
func (m *K8sEventMutation) Where(ps ...predicate.K8sEvent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sEventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sEvent).
func (m *K8sEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sEventMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, k8sevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sevent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sevent.FieldDeletedAt)
	}
	if m.ts != nil {
		fields = append(fields, k8sevent.FieldTs)
	}
	if m.value != nil {
		fields = append(fields, k8sevent.FieldValue)
	}
	if m.endpointId != nil {
		fields = append(fields, k8sevent.FieldEndpointId)
	}
	if m.typeId != nil {
		fields = append(fields, k8sevent.FieldTypeId)
	}
	if m.nameId != nil {
		fields = append(fields, k8sevent.FieldNameId)
	}
	if m.labelId != nil {
		fields = append(fields, k8sevent.FieldLabelId)
	}
	if m.clusterId != nil {
		fields = append(fields, k8sevent.FieldClusterId)
	}
	if m.namespaceId != nil {
		fields = append(fields, k8sevent.FieldNamespaceId)
	}
	if m.nodeId != nil {
		fields = append(fields, k8sevent.FieldNodeId)
	}
	if m.containerId != nil {
		fields = append(fields, k8sevent.FieldContainerId)
	}
	if m.podId != nil {
		fields = append(fields, k8sevent.FieldPodId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sevent.FieldCreatedAt:
		return m.CreatedAt()
	case k8sevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sevent.FieldDeletedAt:
		return m.DeletedAt()
	case k8sevent.FieldTs:
		return m.Ts()
	case k8sevent.FieldValue:
		return m.Value()
	case k8sevent.FieldEndpointId:
		return m.EndpointId()
	case k8sevent.FieldTypeId:
		return m.TypeId()
	case k8sevent.FieldNameId:
		return m.NameId()
	case k8sevent.FieldLabelId:
		return m.LabelId()
	case k8sevent.FieldClusterId:
		return m.ClusterId()
	case k8sevent.FieldNamespaceId:
		return m.NamespaceId()
	case k8sevent.FieldNodeId:
		return m.NodeId()
	case k8sevent.FieldContainerId:
		return m.ContainerId()
	case k8sevent.FieldPodId:
		return m.PodId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sevent.FieldTs:
		return m.OldTs(ctx)
	case k8sevent.FieldValue:
		return m.OldValue(ctx)
	case k8sevent.FieldEndpointId:
		return m.OldEndpointId(ctx)
	case k8sevent.FieldTypeId:
		return m.OldTypeId(ctx)
	case k8sevent.FieldNameId:
		return m.OldNameId(ctx)
	case k8sevent.FieldLabelId:
		return m.OldLabelId(ctx)
	case k8sevent.FieldClusterId:
		return m.OldClusterId(ctx)
	case k8sevent.FieldNamespaceId:
		return m.OldNamespaceId(ctx)
	case k8sevent.FieldNodeId:
		return m.OldNodeId(ctx)
	case k8sevent.FieldContainerId:
		return m.OldContainerId(ctx)
	case k8sevent.FieldPodId:
		return m.OldPodId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sevent.FieldTs:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTs(v)
		return nil
	case k8sevent.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case k8sevent.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointId(v)
		return nil
	case k8sevent.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case k8sevent.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameId(v)
		return nil
	case k8sevent.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelId(v)
		return nil
	case k8sevent.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	case k8sevent.FieldNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceId(v)
		return nil
	case k8sevent.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeId(v)
		return nil
	case k8sevent.FieldContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	case k8sevent.FieldPodId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPodId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sEventMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, k8sevent.FieldValue)
	}
	if m.addendpointId != nil {
		fields = append(fields, k8sevent.FieldEndpointId)
	}
	if m.addtypeId != nil {
		fields = append(fields, k8sevent.FieldTypeId)
	}
	if m.addnameId != nil {
		fields = append(fields, k8sevent.FieldNameId)
	}
	if m.addlabelId != nil {
		fields = append(fields, k8sevent.FieldLabelId)
	}
	if m.addclusterId != nil {
		fields = append(fields, k8sevent.FieldClusterId)
	}
	if m.addnamespaceId != nil {
		fields = append(fields, k8sevent.FieldNamespaceId)
	}
	if m.addnodeId != nil {
		fields = append(fields, k8sevent.FieldNodeId)
	}
	if m.addcontainerId != nil {
		fields = append(fields, k8sevent.FieldContainerId)
	}
	if m.addpodId != nil {
		fields = append(fields, k8sevent.FieldPodId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sevent.FieldValue:
		return m.AddedValue()
	case k8sevent.FieldEndpointId:
		return m.AddedEndpointId()
	case k8sevent.FieldTypeId:
		return m.AddedTypeId()
	case k8sevent.FieldNameId:
		return m.AddedNameId()
	case k8sevent.FieldLabelId:
		return m.AddedLabelId()
	case k8sevent.FieldClusterId:
		return m.AddedClusterId()
	case k8sevent.FieldNamespaceId:
		return m.AddedNamespaceId()
	case k8sevent.FieldNodeId:
		return m.AddedNodeId()
	case k8sevent.FieldContainerId:
		return m.AddedContainerId()
	case k8sevent.FieldPodId:
		return m.AddedPodId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sevent.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case k8sevent.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndpointId(v)
		return nil
	case k8sevent.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case k8sevent.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNameId(v)
		return nil
	case k8sevent.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLabelId(v)
		return nil
	case k8sevent.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClusterId(v)
		return nil
	case k8sevent.FieldNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNamespaceId(v)
		return nil
	case k8sevent.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeId(v)
		return nil
	case k8sevent.FieldContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContainerId(v)
		return nil
	case k8sevent.FieldPodId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPodId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sEventMutation) ResetField(name string) error {
	switch name {
	case k8sevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sevent.FieldTs:
		m.ResetTs()
		return nil
	case k8sevent.FieldValue:
		m.ResetValue()
		return nil
	case k8sevent.FieldEndpointId:
		m.ResetEndpointId()
		return nil
	case k8sevent.FieldTypeId:
		m.ResetTypeId()
		return nil
	case k8sevent.FieldNameId:
		m.ResetNameId()
		return nil
	case k8sevent.FieldLabelId:
		m.ResetLabelId()
		return nil
	case k8sevent.FieldClusterId:
		m.ResetClusterId()
		return nil
	case k8sevent.FieldNamespaceId:
		m.ResetNamespaceId()
		return nil
	case k8sevent.FieldNodeId:
		m.ResetNodeId()
		return nil
	case k8sevent.FieldContainerId:
		m.ResetContainerId()
		return nil
	case k8sevent.FieldPodId:
		m.ResetPodId()
		return nil
	}
	return fmt.Errorf("unknown K8sEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sEvent edge %s", name)
}

// K8sLabelMutation represents an operation that mutates the K8sLabel nodes in the graph.
type K8sLabelMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	label          *string
	k8sObjectId    *uint
	addk8sObjectId *uint
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*K8sLabel, error)
	predicates     []predicate.K8sLabel
}

var _ ent.Mutation = (*K8sLabelMutation)(nil)

// k8slabelOption allows management of the mutation configuration using functional options.
type k8slabelOption func(*K8sLabelMutation)

// newK8sLabelMutation creates new mutation for the K8sLabel entity.
func newK8sLabelMutation(c config, op Op, opts ...k8slabelOption) *K8sLabelMutation {
	m := &K8sLabelMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sLabelID sets the ID field of the mutation.
func withK8sLabelID(id uint) k8slabelOption {
	return func(m *K8sLabelMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sLabel
		)
		m.oldValue = func(ctx context.Context) (*K8sLabel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sLabel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sLabel sets the old K8sLabel of the mutation.
func withK8sLabel(node *K8sLabel) k8slabelOption {
	return func(m *K8sLabelMutation) {
		m.oldValue = func(context.Context) (*K8sLabel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sLabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sLabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sLabel entities.
func (m *K8sLabelMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sLabelMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sLabelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sLabelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sLabel entity.
// If the K8sLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sLabelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sLabelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sLabelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sLabelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sLabel entity.
// If the K8sLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sLabelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sLabelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sLabelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sLabelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sLabel entity.
// If the K8sLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sLabelMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sLabelMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetLabel sets the "label" field.
func (m *K8sLabelMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *K8sLabelMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the K8sLabel entity.
// If the K8sLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sLabelMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *K8sLabelMutation) ResetLabel() {
	m.label = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sLabelMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sLabelMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sLabel entity.
// If the K8sLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sLabelMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sLabelMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sLabelMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sLabelMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sLabelMutation builder.
func (m *K8sLabelMutation) Where(ps ...predicate.K8sLabel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sLabelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sLabel).
func (m *K8sLabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sLabelMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, k8slabel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8slabel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8slabel.FieldDeletedAt)
	}
	if m.label != nil {
		fields = append(fields, k8slabel.FieldLabel)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8slabel.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sLabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8slabel.FieldCreatedAt:
		return m.CreatedAt()
	case k8slabel.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8slabel.FieldDeletedAt:
		return m.DeletedAt()
	case k8slabel.FieldLabel:
		return m.Label()
	case k8slabel.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sLabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8slabel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8slabel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8slabel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8slabel.FieldLabel:
		return m.OldLabel(ctx)
	case k8slabel.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sLabel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sLabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8slabel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8slabel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8slabel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8slabel.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case k8slabel.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sLabel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sLabelMutation) AddedFields() []string {
	var fields []string
	if m.addk8sObjectId != nil {
		fields = append(fields, k8slabel.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sLabelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8slabel.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sLabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8slabel.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sLabel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sLabelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sLabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sLabelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sLabel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sLabelMutation) ResetField(name string) error {
	switch name {
	case k8slabel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8slabel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8slabel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8slabel.FieldLabel:
		m.ResetLabel()
		return nil
	case k8slabel.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sLabel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sLabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sLabelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sLabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sLabelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sLabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sLabelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sLabelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sLabel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sLabelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sLabel edge %s", name)
}

// K8sMetricMutation represents an operation that mutates the K8sMetric nodes in the graph.
type K8sMetricMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	ts                *time.Time
	value             *float64
	addvalue          *float64
	endpointId        *uint
	addendpointId     *uint
	typeId            *uint
	addtypeId         *uint
	nameId            *uint
	addnameId         *uint
	labelId           *uint
	addlabelId        *uint
	k8sClusterId      *uint
	addk8sClusterId   *uint
	k8sNodeId         *uint
	addk8sNodeId      *uint
	k8sNamespaceId    *uint
	addk8sNamespaceId *uint
	k8sContainerId    *uint
	addk8sContainerId *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sMetric, error)
	predicates        []predicate.K8sMetric
}

var _ ent.Mutation = (*K8sMetricMutation)(nil)

// k8smetricOption allows management of the mutation configuration using functional options.
type k8smetricOption func(*K8sMetricMutation)

// newK8sMetricMutation creates new mutation for the K8sMetric entity.
func newK8sMetricMutation(c config, op Op, opts ...k8smetricOption) *K8sMetricMutation {
	m := &K8sMetricMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sMetricID sets the ID field of the mutation.
func withK8sMetricID(id int) k8smetricOption {
	return func(m *K8sMetricMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sMetric
		)
		m.oldValue = func(ctx context.Context) (*K8sMetric, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sMetric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sMetric sets the old K8sMetric of the mutation.
func withK8sMetric(node *K8sMetric) k8smetricOption {
	return func(m *K8sMetricMutation) {
		m.oldValue = func(context.Context) (*K8sMetric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sMetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sMetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sMetricMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sMetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sMetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sMetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sMetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sMetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sMetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sMetricMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sMetricMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sMetricMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTs sets the "ts" field.
func (m *K8sMetricMutation) SetTs(t time.Time) {
	m.ts = &t
}

// Ts returns the value of the "ts" field in the mutation.
func (m *K8sMetricMutation) Ts() (r time.Time, exists bool) {
	v := m.ts
	if v == nil {
		return
	}
	return *v, true
}

// OldTs returns the old "ts" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldTs(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTs: %w", err)
	}
	return oldValue.Ts, nil
}

// ResetTs resets all changes to the "ts" field.
func (m *K8sMetricMutation) ResetTs() {
	m.ts = nil
}

// SetValue sets the "value" field.
func (m *K8sMetricMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *K8sMetricMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *K8sMetricMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *K8sMetricMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *K8sMetricMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetEndpointId sets the "endpointId" field.
func (m *K8sMetricMutation) SetEndpointId(u uint) {
	m.endpointId = &u
	m.addendpointId = nil
}

// EndpointId returns the value of the "endpointId" field in the mutation.
func (m *K8sMetricMutation) EndpointId() (r uint, exists bool) {
	v := m.endpointId
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointId returns the old "endpointId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldEndpointId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndpointId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndpointId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointId: %w", err)
	}
	return oldValue.EndpointId, nil
}

// AddEndpointId adds u to the "endpointId" field.
func (m *K8sMetricMutation) AddEndpointId(u uint) {
	if m.addendpointId != nil {
		*m.addendpointId += u
	} else {
		m.addendpointId = &u
	}
}

// AddedEndpointId returns the value that was added to the "endpointId" field in this mutation.
func (m *K8sMetricMutation) AddedEndpointId() (r uint, exists bool) {
	v := m.addendpointId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndpointId resets all changes to the "endpointId" field.
func (m *K8sMetricMutation) ResetEndpointId() {
	m.endpointId = nil
	m.addendpointId = nil
}

// SetTypeId sets the "typeId" field.
func (m *K8sMetricMutation) SetTypeId(u uint) {
	m.typeId = &u
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *K8sMetricMutation) TypeId() (r uint, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldTypeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds u to the "typeId" field.
func (m *K8sMetricMutation) AddTypeId(u uint) {
	if m.addtypeId != nil {
		*m.addtypeId += u
	} else {
		m.addtypeId = &u
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *K8sMetricMutation) AddedTypeId() (r uint, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *K8sMetricMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// SetNameId sets the "nameId" field.
func (m *K8sMetricMutation) SetNameId(u uint) {
	m.nameId = &u
	m.addnameId = nil
}

// NameId returns the value of the "nameId" field in the mutation.
func (m *K8sMetricMutation) NameId() (r uint, exists bool) {
	v := m.nameId
	if v == nil {
		return
	}
	return *v, true
}

// OldNameId returns the old "nameId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldNameId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNameId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNameId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameId: %w", err)
	}
	return oldValue.NameId, nil
}

// AddNameId adds u to the "nameId" field.
func (m *K8sMetricMutation) AddNameId(u uint) {
	if m.addnameId != nil {
		*m.addnameId += u
	} else {
		m.addnameId = &u
	}
}

// AddedNameId returns the value that was added to the "nameId" field in this mutation.
func (m *K8sMetricMutation) AddedNameId() (r uint, exists bool) {
	v := m.addnameId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNameId resets all changes to the "nameId" field.
func (m *K8sMetricMutation) ResetNameId() {
	m.nameId = nil
	m.addnameId = nil
}

// SetLabelId sets the "labelId" field.
func (m *K8sMetricMutation) SetLabelId(u uint) {
	m.labelId = &u
	m.addlabelId = nil
}

// LabelId returns the value of the "labelId" field in the mutation.
func (m *K8sMetricMutation) LabelId() (r uint, exists bool) {
	v := m.labelId
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelId returns the old "labelId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldLabelId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelId: %w", err)
	}
	return oldValue.LabelId, nil
}

// AddLabelId adds u to the "labelId" field.
func (m *K8sMetricMutation) AddLabelId(u uint) {
	if m.addlabelId != nil {
		*m.addlabelId += u
	} else {
		m.addlabelId = &u
	}
}

// AddedLabelId returns the value that was added to the "labelId" field in this mutation.
func (m *K8sMetricMutation) AddedLabelId() (r uint, exists bool) {
	v := m.addlabelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetLabelId resets all changes to the "labelId" field.
func (m *K8sMetricMutation) ResetLabelId() {
	m.labelId = nil
	m.addlabelId = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sMetricMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sMetricMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sMetricMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sMetricMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sMetricMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNodeId sets the "k8sNodeId" field.
func (m *K8sMetricMutation) SetK8sNodeId(u uint) {
	m.k8sNodeId = &u
	m.addk8sNodeId = nil
}

// K8sNodeId returns the value of the "k8sNodeId" field in the mutation.
func (m *K8sMetricMutation) K8sNodeId() (r uint, exists bool) {
	v := m.k8sNodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNodeId returns the old "k8sNodeId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldK8sNodeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNodeId: %w", err)
	}
	return oldValue.K8sNodeId, nil
}

// AddK8sNodeId adds u to the "k8sNodeId" field.
func (m *K8sMetricMutation) AddK8sNodeId(u uint) {
	if m.addk8sNodeId != nil {
		*m.addk8sNodeId += u
	} else {
		m.addk8sNodeId = &u
	}
}

// AddedK8sNodeId returns the value that was added to the "k8sNodeId" field in this mutation.
func (m *K8sMetricMutation) AddedK8sNodeId() (r uint, exists bool) {
	v := m.addk8sNodeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNodeId resets all changes to the "k8sNodeId" field.
func (m *K8sMetricMutation) ResetK8sNodeId() {
	m.k8sNodeId = nil
	m.addk8sNodeId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sMetricMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sMetricMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sMetricMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sMetricMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sMetricMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sContainerId sets the "k8sContainerId" field.
func (m *K8sMetricMutation) SetK8sContainerId(u uint) {
	m.k8sContainerId = &u
	m.addk8sContainerId = nil
}

// K8sContainerId returns the value of the "k8sContainerId" field in the mutation.
func (m *K8sMetricMutation) K8sContainerId() (r uint, exists bool) {
	v := m.k8sContainerId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sContainerId returns the old "k8sContainerId" field's value of the K8sMetric entity.
// If the K8sMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sMetricMutation) OldK8sContainerId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sContainerId: %w", err)
	}
	return oldValue.K8sContainerId, nil
}

// AddK8sContainerId adds u to the "k8sContainerId" field.
func (m *K8sMetricMutation) AddK8sContainerId(u uint) {
	if m.addk8sContainerId != nil {
		*m.addk8sContainerId += u
	} else {
		m.addk8sContainerId = &u
	}
}

// AddedK8sContainerId returns the value that was added to the "k8sContainerId" field in this mutation.
func (m *K8sMetricMutation) AddedK8sContainerId() (r uint, exists bool) {
	v := m.addk8sContainerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sContainerId resets all changes to the "k8sContainerId" field.
func (m *K8sMetricMutation) ResetK8sContainerId() {
	m.k8sContainerId = nil
	m.addk8sContainerId = nil
}

// Where appends a list predicates to the K8sMetricMutation builder.
func (m *K8sMetricMutation) Where(ps ...predicate.K8sMetric) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sMetricMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sMetric).
func (m *K8sMetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sMetricMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, k8smetric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8smetric.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8smetric.FieldDeletedAt)
	}
	if m.ts != nil {
		fields = append(fields, k8smetric.FieldTs)
	}
	if m.value != nil {
		fields = append(fields, k8smetric.FieldValue)
	}
	if m.endpointId != nil {
		fields = append(fields, k8smetric.FieldEndpointId)
	}
	if m.typeId != nil {
		fields = append(fields, k8smetric.FieldTypeId)
	}
	if m.nameId != nil {
		fields = append(fields, k8smetric.FieldNameId)
	}
	if m.labelId != nil {
		fields = append(fields, k8smetric.FieldLabelId)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8smetric.FieldK8sClusterId)
	}
	if m.k8sNodeId != nil {
		fields = append(fields, k8smetric.FieldK8sNodeId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8smetric.FieldK8sNamespaceId)
	}
	if m.k8sContainerId != nil {
		fields = append(fields, k8smetric.FieldK8sContainerId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sMetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8smetric.FieldCreatedAt:
		return m.CreatedAt()
	case k8smetric.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8smetric.FieldDeletedAt:
		return m.DeletedAt()
	case k8smetric.FieldTs:
		return m.Ts()
	case k8smetric.FieldValue:
		return m.Value()
	case k8smetric.FieldEndpointId:
		return m.EndpointId()
	case k8smetric.FieldTypeId:
		return m.TypeId()
	case k8smetric.FieldNameId:
		return m.NameId()
	case k8smetric.FieldLabelId:
		return m.LabelId()
	case k8smetric.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8smetric.FieldK8sNodeId:
		return m.K8sNodeId()
	case k8smetric.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8smetric.FieldK8sContainerId:
		return m.K8sContainerId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sMetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8smetric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8smetric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8smetric.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8smetric.FieldTs:
		return m.OldTs(ctx)
	case k8smetric.FieldValue:
		return m.OldValue(ctx)
	case k8smetric.FieldEndpointId:
		return m.OldEndpointId(ctx)
	case k8smetric.FieldTypeId:
		return m.OldTypeId(ctx)
	case k8smetric.FieldNameId:
		return m.OldNameId(ctx)
	case k8smetric.FieldLabelId:
		return m.OldLabelId(ctx)
	case k8smetric.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8smetric.FieldK8sNodeId:
		return m.OldK8sNodeId(ctx)
	case k8smetric.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8smetric.FieldK8sContainerId:
		return m.OldK8sContainerId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sMetric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sMetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8smetric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8smetric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8smetric.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8smetric.FieldTs:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTs(v)
		return nil
	case k8smetric.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case k8smetric.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointId(v)
		return nil
	case k8smetric.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case k8smetric.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameId(v)
		return nil
	case k8smetric.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelId(v)
		return nil
	case k8smetric.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8smetric.FieldK8sNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNodeId(v)
		return nil
	case k8smetric.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8smetric.FieldK8sContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sContainerId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sMetric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sMetricMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, k8smetric.FieldValue)
	}
	if m.addendpointId != nil {
		fields = append(fields, k8smetric.FieldEndpointId)
	}
	if m.addtypeId != nil {
		fields = append(fields, k8smetric.FieldTypeId)
	}
	if m.addnameId != nil {
		fields = append(fields, k8smetric.FieldNameId)
	}
	if m.addlabelId != nil {
		fields = append(fields, k8smetric.FieldLabelId)
	}
	if m.addk8sClusterId != nil {
		fields = append(fields, k8smetric.FieldK8sClusterId)
	}
	if m.addk8sNodeId != nil {
		fields = append(fields, k8smetric.FieldK8sNodeId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8smetric.FieldK8sNamespaceId)
	}
	if m.addk8sContainerId != nil {
		fields = append(fields, k8smetric.FieldK8sContainerId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sMetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8smetric.FieldValue:
		return m.AddedValue()
	case k8smetric.FieldEndpointId:
		return m.AddedEndpointId()
	case k8smetric.FieldTypeId:
		return m.AddedTypeId()
	case k8smetric.FieldNameId:
		return m.AddedNameId()
	case k8smetric.FieldLabelId:
		return m.AddedLabelId()
	case k8smetric.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8smetric.FieldK8sNodeId:
		return m.AddedK8sNodeId()
	case k8smetric.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8smetric.FieldK8sContainerId:
		return m.AddedK8sContainerId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sMetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8smetric.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case k8smetric.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndpointId(v)
		return nil
	case k8smetric.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case k8smetric.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNameId(v)
		return nil
	case k8smetric.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLabelId(v)
		return nil
	case k8smetric.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8smetric.FieldK8sNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNodeId(v)
		return nil
	case k8smetric.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8smetric.FieldK8sContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sContainerId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sMetric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sMetricMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sMetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sMetricMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sMetric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sMetricMutation) ResetField(name string) error {
	switch name {
	case k8smetric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8smetric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8smetric.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8smetric.FieldTs:
		m.ResetTs()
		return nil
	case k8smetric.FieldValue:
		m.ResetValue()
		return nil
	case k8smetric.FieldEndpointId:
		m.ResetEndpointId()
		return nil
	case k8smetric.FieldTypeId:
		m.ResetTypeId()
		return nil
	case k8smetric.FieldNameId:
		m.ResetNameId()
		return nil
	case k8smetric.FieldLabelId:
		m.ResetLabelId()
		return nil
	case k8smetric.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8smetric.FieldK8sNodeId:
		m.ResetK8sNodeId()
		return nil
	case k8smetric.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8smetric.FieldK8sContainerId:
		m.ResetK8sContainerId()
		return nil
	}
	return fmt.Errorf("unknown K8sMetric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sMetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sMetricMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sMetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sMetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sMetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sMetricMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sMetricMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sMetric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sMetricMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sMetric edge %s", name)
}

// K8sNamespaceMutation represents an operation that mutates the K8sNamespace nodes in the graph.
type K8sNamespaceMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	k8sClusterId    *uint
	addk8sClusterId *uint
	k8sObjectId     *uint
	addk8sObjectId  *uint
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*K8sNamespace, error)
	predicates      []predicate.K8sNamespace
}

var _ ent.Mutation = (*K8sNamespaceMutation)(nil)

// k8snamespaceOption allows management of the mutation configuration using functional options.
type k8snamespaceOption func(*K8sNamespaceMutation)

// newK8sNamespaceMutation creates new mutation for the K8sNamespace entity.
func newK8sNamespaceMutation(c config, op Op, opts ...k8snamespaceOption) *K8sNamespaceMutation {
	m := &K8sNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sNamespaceID sets the ID field of the mutation.
func withK8sNamespaceID(id uint) k8snamespaceOption {
	return func(m *K8sNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sNamespace
		)
		m.oldValue = func(ctx context.Context) (*K8sNamespace, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sNamespace sets the old K8sNamespace of the mutation.
func withK8sNamespace(node *K8sNamespace) k8snamespaceOption {
	return func(m *K8sNamespaceMutation) {
		m.oldValue = func(context.Context) (*K8sNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sNamespace entities.
func (m *K8sNamespaceMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sNamespaceMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sNamespaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sNamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sNamespace entity.
// If the K8sNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sNamespaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sNamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sNamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sNamespace entity.
// If the K8sNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sNamespaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sNamespaceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sNamespaceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sNamespace entity.
// If the K8sNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNamespaceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sNamespaceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sNamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sNamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sNamespace entity.
// If the K8sNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sNamespaceMutation) ResetName() {
	m.name = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sNamespaceMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sNamespaceMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sNamespace entity.
// If the K8sNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNamespaceMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sNamespaceMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sNamespaceMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sNamespaceMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sNamespaceMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sNamespaceMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sNamespace entity.
// If the K8sNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNamespaceMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sNamespaceMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sNamespaceMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sNamespaceMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sNamespaceMutation builder.
func (m *K8sNamespaceMutation) Where(ps ...predicate.K8sNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sNamespaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sNamespace).
func (m *K8sNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, k8snamespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8snamespace.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8snamespace.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8snamespace.FieldName)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8snamespace.FieldK8sClusterId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8snamespace.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8snamespace.FieldCreatedAt:
		return m.CreatedAt()
	case k8snamespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8snamespace.FieldDeletedAt:
		return m.DeletedAt()
	case k8snamespace.FieldName:
		return m.Name()
	case k8snamespace.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8snamespace.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8snamespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8snamespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8snamespace.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8snamespace.FieldName:
		return m.OldName(ctx)
	case k8snamespace.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8snamespace.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8snamespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8snamespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8snamespace.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8snamespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8snamespace.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8snamespace.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sNamespaceMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8snamespace.FieldK8sClusterId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8snamespace.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8snamespace.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8snamespace.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8snamespace.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8snamespace.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sNamespaceMutation) ResetField(name string) error {
	switch name {
	case k8snamespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8snamespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8snamespace.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8snamespace.FieldName:
		m.ResetName()
		return nil
	case k8snamespace.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8snamespace.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sNamespaceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sNamespaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sNamespaceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sNamespaceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sNamespaceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sNamespace edge %s", name)
}

// K8sNodeMutation represents an operation that mutates the K8sNode nodes in the graph.
type K8sNodeMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	k8sClusterId    *uint
	addk8sClusterId *uint
	k8sObjectId     *uint
	addk8sObjectId  *uint
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*K8sNode, error)
	predicates      []predicate.K8sNode
}

var _ ent.Mutation = (*K8sNodeMutation)(nil)

// k8snodeOption allows management of the mutation configuration using functional options.
type k8snodeOption func(*K8sNodeMutation)

// newK8sNodeMutation creates new mutation for the K8sNode entity.
func newK8sNodeMutation(c config, op Op, opts ...k8snodeOption) *K8sNodeMutation {
	m := &K8sNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sNodeID sets the ID field of the mutation.
func withK8sNodeID(id uint) k8snodeOption {
	return func(m *K8sNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sNode
		)
		m.oldValue = func(ctx context.Context) (*K8sNode, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sNode sets the old K8sNode of the mutation.
func withK8sNode(node *K8sNode) k8snodeOption {
	return func(m *K8sNodeMutation) {
		m.oldValue = func(context.Context) (*K8sNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sNode entities.
func (m *K8sNodeMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sNodeMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sNodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sNodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sNode entity.
// If the K8sNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sNodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sNodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sNodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sNode entity.
// If the K8sNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sNodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sNodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sNodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sNode entity.
// If the K8sNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNodeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sNodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sNodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sNodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sNode entity.
// If the K8sNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sNodeMutation) ResetName() {
	m.name = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sNodeMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sNodeMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sNode entity.
// If the K8sNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNodeMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sNodeMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sNodeMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sNodeMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sNodeMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sNodeMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sNode entity.
// If the K8sNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sNodeMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sNodeMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sNodeMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sNodeMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sNodeMutation builder.
func (m *K8sNodeMutation) Where(ps ...predicate.K8sNode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sNodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sNode).
func (m *K8sNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sNodeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, k8snode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8snode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8snode.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8snode.FieldName)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8snode.FieldK8sClusterId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8snode.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8snode.FieldCreatedAt:
		return m.CreatedAt()
	case k8snode.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8snode.FieldDeletedAt:
		return m.DeletedAt()
	case k8snode.FieldName:
		return m.Name()
	case k8snode.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8snode.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8snode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8snode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8snode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8snode.FieldName:
		return m.OldName(ctx)
	case k8snode.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8snode.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8snode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8snode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8snode.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8snode.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8snode.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8snode.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sNodeMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8snode.FieldK8sClusterId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8snode.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8snode.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8snode.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8snode.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8snode.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sNodeMutation) ResetField(name string) error {
	switch name {
	case k8snode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8snode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8snode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8snode.FieldName:
		m.ResetName()
		return nil
	case k8snode.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8snode.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sNodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sNodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sNodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sNodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sNodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sNode edge %s", name)
}

// K8sObjectMutation represents an operation that mutates the K8sObject nodes in the graph.
type K8sObjectMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	k8sClusterId    *uint
	addk8sClusterId *uint
	apiVersion      *string
	kind            *string
	name            *string
	metadata        *[]string
	spec            *[]string
	status          *[]string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*K8sObject, error)
	predicates      []predicate.K8sObject
}

var _ ent.Mutation = (*K8sObjectMutation)(nil)

// k8sobjectOption allows management of the mutation configuration using functional options.
type k8sobjectOption func(*K8sObjectMutation)

// newK8sObjectMutation creates new mutation for the K8sObject entity.
func newK8sObjectMutation(c config, op Op, opts ...k8sobjectOption) *K8sObjectMutation {
	m := &K8sObjectMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sObject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sObjectID sets the ID field of the mutation.
func withK8sObjectID(id uint) k8sobjectOption {
	return func(m *K8sObjectMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sObject
		)
		m.oldValue = func(ctx context.Context) (*K8sObject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sObject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sObject sets the old K8sObject of the mutation.
func withK8sObject(node *K8sObject) k8sobjectOption {
	return func(m *K8sObjectMutation) {
		m.oldValue = func(context.Context) (*K8sObject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sObjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sObjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sObject entities.
func (m *K8sObjectMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sObjectMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sObjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sObjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sObjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sObjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sObjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sObjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sObjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sObjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sObjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sObjectMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sObjectMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sObjectMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sObjectMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sObjectMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetApiVersion sets the "apiVersion" field.
func (m *K8sObjectMutation) SetApiVersion(s string) {
	m.apiVersion = &s
}

// ApiVersion returns the value of the "apiVersion" field in the mutation.
func (m *K8sObjectMutation) ApiVersion() (r string, exists bool) {
	v := m.apiVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldApiVersion returns the old "apiVersion" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldApiVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApiVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApiVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApiVersion: %w", err)
	}
	return oldValue.ApiVersion, nil
}

// ResetApiVersion resets all changes to the "apiVersion" field.
func (m *K8sObjectMutation) ResetApiVersion() {
	m.apiVersion = nil
}

// SetKind sets the "kind" field.
func (m *K8sObjectMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *K8sObjectMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *K8sObjectMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *K8sObjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sObjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sObjectMutation) ResetName() {
	m.name = nil
}

// SetMetadata sets the "metadata" field.
func (m *K8sObjectMutation) SetMetadata(s []string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *K8sObjectMutation) Metadata() (r []string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldMetadata(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *K8sObjectMutation) ResetMetadata() {
	m.metadata = nil
}

// SetSpec sets the "spec" field.
func (m *K8sObjectMutation) SetSpec(s []string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *K8sObjectMutation) Spec() (r []string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldSpec(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ResetSpec resets all changes to the "spec" field.
func (m *K8sObjectMutation) ResetSpec() {
	m.spec = nil
}

// SetStatus sets the "status" field.
func (m *K8sObjectMutation) SetStatus(s []string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *K8sObjectMutation) Status() (r []string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the K8sObject entity.
// If the K8sObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectMutation) OldStatus(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *K8sObjectMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the K8sObjectMutation builder.
func (m *K8sObjectMutation) Where(ps ...predicate.K8sObject) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sObjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sObject).
func (m *K8sObjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sObjectMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, k8sobject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sobject.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sobject.FieldDeletedAt)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8sobject.FieldK8sClusterId)
	}
	if m.apiVersion != nil {
		fields = append(fields, k8sobject.FieldApiVersion)
	}
	if m.kind != nil {
		fields = append(fields, k8sobject.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, k8sobject.FieldName)
	}
	if m.metadata != nil {
		fields = append(fields, k8sobject.FieldMetadata)
	}
	if m.spec != nil {
		fields = append(fields, k8sobject.FieldSpec)
	}
	if m.status != nil {
		fields = append(fields, k8sobject.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sObjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sobject.FieldCreatedAt:
		return m.CreatedAt()
	case k8sobject.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sobject.FieldDeletedAt:
		return m.DeletedAt()
	case k8sobject.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8sobject.FieldApiVersion:
		return m.ApiVersion()
	case k8sobject.FieldKind:
		return m.Kind()
	case k8sobject.FieldName:
		return m.Name()
	case k8sobject.FieldMetadata:
		return m.Metadata()
	case k8sobject.FieldSpec:
		return m.Spec()
	case k8sobject.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sObjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sobject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sobject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sobject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sobject.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8sobject.FieldApiVersion:
		return m.OldApiVersion(ctx)
	case k8sobject.FieldKind:
		return m.OldKind(ctx)
	case k8sobject.FieldName:
		return m.OldName(ctx)
	case k8sobject.FieldMetadata:
		return m.OldMetadata(ctx)
	case k8sobject.FieldSpec:
		return m.OldSpec(ctx)
	case k8sobject.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown K8sObject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sObjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sobject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sobject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sobject.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sobject.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8sobject.FieldApiVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApiVersion(v)
		return nil
	case k8sobject.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case k8sobject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8sobject.FieldMetadata:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case k8sobject.FieldSpec:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case k8sobject.FieldStatus:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown K8sObject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sObjectMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8sobject.FieldK8sClusterId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sObjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sobject.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sObjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sobject.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sObject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sObjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sObjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sObjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sObject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sObjectMutation) ResetField(name string) error {
	switch name {
	case k8sobject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sobject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sobject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sobject.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8sobject.FieldApiVersion:
		m.ResetApiVersion()
		return nil
	case k8sobject.FieldKind:
		m.ResetKind()
		return nil
	case k8sobject.FieldName:
		m.ResetName()
		return nil
	case k8sobject.FieldMetadata:
		m.ResetMetadata()
		return nil
	case k8sobject.FieldSpec:
		m.ResetSpec()
		return nil
	case k8sobject.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown K8sObject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sObjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sObjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sObjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sObjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sObjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sObjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sObjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sObject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sObjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sObject edge %s", name)
}

// K8sObjectTagMutation represents an operation that mutates the K8sObjectTag nodes in the graph.
type K8sObjectTagMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	k8sObjectId    *uint
	addk8sObjectId *uint
	k8sLabelId     *uint
	addk8sLabelId  *uint
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*K8sObjectTag, error)
	predicates     []predicate.K8sObjectTag
}

var _ ent.Mutation = (*K8sObjectTagMutation)(nil)

// k8sobjecttagOption allows management of the mutation configuration using functional options.
type k8sobjecttagOption func(*K8sObjectTagMutation)

// newK8sObjectTagMutation creates new mutation for the K8sObjectTag entity.
func newK8sObjectTagMutation(c config, op Op, opts ...k8sobjecttagOption) *K8sObjectTagMutation {
	m := &K8sObjectTagMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sObjectTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sObjectTagID sets the ID field of the mutation.
func withK8sObjectTagID(id uint) k8sobjecttagOption {
	return func(m *K8sObjectTagMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sObjectTag
		)
		m.oldValue = func(ctx context.Context) (*K8sObjectTag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sObjectTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sObjectTag sets the old K8sObjectTag of the mutation.
func withK8sObjectTag(node *K8sObjectTag) k8sobjecttagOption {
	return func(m *K8sObjectTagMutation) {
		m.oldValue = func(context.Context) (*K8sObjectTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sObjectTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sObjectTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sObjectTag entities.
func (m *K8sObjectTagMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sObjectTagMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sObjectTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sObjectTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sObjectTag entity.
// If the K8sObjectTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sObjectTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sObjectTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sObjectTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sObjectTag entity.
// If the K8sObjectTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sObjectTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sObjectTagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sObjectTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sObjectTag entity.
// If the K8sObjectTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectTagMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sObjectTagMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sObjectTagMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sObjectTagMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sObjectTag entity.
// If the K8sObjectTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectTagMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sObjectTagMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sObjectTagMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sObjectTagMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// SetK8sLabelId sets the "k8sLabelId" field.
func (m *K8sObjectTagMutation) SetK8sLabelId(u uint) {
	m.k8sLabelId = &u
	m.addk8sLabelId = nil
}

// K8sLabelId returns the value of the "k8sLabelId" field in the mutation.
func (m *K8sObjectTagMutation) K8sLabelId() (r uint, exists bool) {
	v := m.k8sLabelId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sLabelId returns the old "k8sLabelId" field's value of the K8sObjectTag entity.
// If the K8sObjectTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sObjectTagMutation) OldK8sLabelId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sLabelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sLabelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sLabelId: %w", err)
	}
	return oldValue.K8sLabelId, nil
}

// AddK8sLabelId adds u to the "k8sLabelId" field.
func (m *K8sObjectTagMutation) AddK8sLabelId(u uint) {
	if m.addk8sLabelId != nil {
		*m.addk8sLabelId += u
	} else {
		m.addk8sLabelId = &u
	}
}

// AddedK8sLabelId returns the value that was added to the "k8sLabelId" field in this mutation.
func (m *K8sObjectTagMutation) AddedK8sLabelId() (r uint, exists bool) {
	v := m.addk8sLabelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sLabelId resets all changes to the "k8sLabelId" field.
func (m *K8sObjectTagMutation) ResetK8sLabelId() {
	m.k8sLabelId = nil
	m.addk8sLabelId = nil
}

// Where appends a list predicates to the K8sObjectTagMutation builder.
func (m *K8sObjectTagMutation) Where(ps ...predicate.K8sObjectTag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sObjectTagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sObjectTag).
func (m *K8sObjectTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sObjectTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, k8sobjecttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sobjecttag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sobjecttag.FieldDeletedAt)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8sobjecttag.FieldK8sObjectId)
	}
	if m.k8sLabelId != nil {
		fields = append(fields, k8sobjecttag.FieldK8sLabelId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sObjectTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sobjecttag.FieldCreatedAt:
		return m.CreatedAt()
	case k8sobjecttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sobjecttag.FieldDeletedAt:
		return m.DeletedAt()
	case k8sobjecttag.FieldK8sObjectId:
		return m.K8sObjectId()
	case k8sobjecttag.FieldK8sLabelId:
		return m.K8sLabelId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sObjectTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sobjecttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sobjecttag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sobjecttag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sobjecttag.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	case k8sobjecttag.FieldK8sLabelId:
		return m.OldK8sLabelId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sObjectTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sObjectTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sobjecttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sobjecttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sobjecttag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sobjecttag.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	case k8sobjecttag.FieldK8sLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sLabelId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sObjectTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sObjectTagMutation) AddedFields() []string {
	var fields []string
	if m.addk8sObjectId != nil {
		fields = append(fields, k8sobjecttag.FieldK8sObjectId)
	}
	if m.addk8sLabelId != nil {
		fields = append(fields, k8sobjecttag.FieldK8sLabelId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sObjectTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sobjecttag.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	case k8sobjecttag.FieldK8sLabelId:
		return m.AddedK8sLabelId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sObjectTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sobjecttag.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	case k8sobjecttag.FieldK8sLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sLabelId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sObjectTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sObjectTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sObjectTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sObjectTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sObjectTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sObjectTagMutation) ResetField(name string) error {
	switch name {
	case k8sobjecttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sobjecttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sobjecttag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sobjecttag.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	case k8sobjecttag.FieldK8sLabelId:
		m.ResetK8sLabelId()
		return nil
	}
	return fmt.Errorf("unknown K8sObjectTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sObjectTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sObjectTagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sObjectTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sObjectTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sObjectTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sObjectTagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sObjectTagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sObjectTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sObjectTagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sObjectTag edge %s", name)
}

// K8sPodMutation represents an operation that mutates the K8sPod nodes in the graph.
type K8sPodMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	qos               *string
	k8sClusterId      *uint
	addk8sClusterId   *uint
	k8sNamespaceId    *uint
	addk8sNamespaceId *uint
	k8sObjectId       *uint
	addk8sObjectId    *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sPod, error)
	predicates        []predicate.K8sPod
}

var _ ent.Mutation = (*K8sPodMutation)(nil)

// k8spodOption allows management of the mutation configuration using functional options.
type k8spodOption func(*K8sPodMutation)

// newK8sPodMutation creates new mutation for the K8sPod entity.
func newK8sPodMutation(c config, op Op, opts ...k8spodOption) *K8sPodMutation {
	m := &K8sPodMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sPod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sPodID sets the ID field of the mutation.
func withK8sPodID(id uint) k8spodOption {
	return func(m *K8sPodMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sPod
		)
		m.oldValue = func(ctx context.Context) (*K8sPod, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sPod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sPod sets the old K8sPod of the mutation.
func withK8sPod(node *K8sPod) k8spodOption {
	return func(m *K8sPodMutation) {
		m.oldValue = func(context.Context) (*K8sPod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sPodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sPodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sPod entities.
func (m *K8sPodMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sPodMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sPodMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sPodMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sPodMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sPodMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sPodMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sPodMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sPodMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sPodMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sPodMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sPodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sPodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sPodMutation) ResetName() {
	m.name = nil
}

// SetQos sets the "qos" field.
func (m *K8sPodMutation) SetQos(s string) {
	m.qos = &s
}

// Qos returns the value of the "qos" field in the mutation.
func (m *K8sPodMutation) Qos() (r string, exists bool) {
	v := m.qos
	if v == nil {
		return
	}
	return *v, true
}

// OldQos returns the old "qos" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldQos(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQos: %w", err)
	}
	return oldValue.Qos, nil
}

// ResetQos resets all changes to the "qos" field.
func (m *K8sPodMutation) ResetQos() {
	m.qos = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sPodMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sPodMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sPodMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sPodMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sPodMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sPodMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sPodMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sPodMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sPodMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sPodMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sPodMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sPodMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sPod entity.
// If the K8sPod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sPodMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sPodMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sPodMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sPodMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sPodMutation builder.
func (m *K8sPodMutation) Where(ps ...predicate.K8sPod) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sPodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sPod).
func (m *K8sPodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sPodMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, k8spod.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8spod.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8spod.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8spod.FieldName)
	}
	if m.qos != nil {
		fields = append(fields, k8spod.FieldQos)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8spod.FieldK8sClusterId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8spod.FieldK8sNamespaceId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8spod.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sPodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8spod.FieldCreatedAt:
		return m.CreatedAt()
	case k8spod.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8spod.FieldDeletedAt:
		return m.DeletedAt()
	case k8spod.FieldName:
		return m.Name()
	case k8spod.FieldQos:
		return m.Qos()
	case k8spod.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8spod.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8spod.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sPodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8spod.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8spod.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8spod.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8spod.FieldName:
		return m.OldName(ctx)
	case k8spod.FieldQos:
		return m.OldQos(ctx)
	case k8spod.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8spod.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8spod.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sPod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sPodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8spod.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8spod.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8spod.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8spod.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8spod.FieldQos:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQos(v)
		return nil
	case k8spod.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8spod.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8spod.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sPod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sPodMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8spod.FieldK8sClusterId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8spod.FieldK8sNamespaceId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8spod.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sPodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8spod.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8spod.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8spod.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sPodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8spod.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8spod.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8spod.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sPod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sPodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sPodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sPodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sPod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sPodMutation) ResetField(name string) error {
	switch name {
	case k8spod.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8spod.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8spod.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8spod.FieldName:
		m.ResetName()
		return nil
	case k8spod.FieldQos:
		m.ResetQos()
		return nil
	case k8spod.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8spod.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8spod.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sPod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sPodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sPodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sPodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sPodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sPodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sPodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sPodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sPod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sPodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sPod edge %s", name)
}

// K8sReplicaSetMutation represents an operation that mutates the K8sReplicaSet nodes in the graph.
type K8sReplicaSetMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	k8sClusterId       *uint
	addk8sClusterId    *uint
	k8sNamespaceId     *uint
	addk8sNamespaceId  *uint
	k8sDeploymentId    *uint
	addk8sDeploymentId *uint
	k8sObjectId        *uint
	addk8sObjectId     *uint
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*K8sReplicaSet, error)
	predicates         []predicate.K8sReplicaSet
}

var _ ent.Mutation = (*K8sReplicaSetMutation)(nil)

// k8sreplicasetOption allows management of the mutation configuration using functional options.
type k8sreplicasetOption func(*K8sReplicaSetMutation)

// newK8sReplicaSetMutation creates new mutation for the K8sReplicaSet entity.
func newK8sReplicaSetMutation(c config, op Op, opts ...k8sreplicasetOption) *K8sReplicaSetMutation {
	m := &K8sReplicaSetMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sReplicaSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sReplicaSetID sets the ID field of the mutation.
func withK8sReplicaSetID(id uint) k8sreplicasetOption {
	return func(m *K8sReplicaSetMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sReplicaSet
		)
		m.oldValue = func(ctx context.Context) (*K8sReplicaSet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sReplicaSet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sReplicaSet sets the old K8sReplicaSet of the mutation.
func withK8sReplicaSet(node *K8sReplicaSet) k8sreplicasetOption {
	return func(m *K8sReplicaSetMutation) {
		m.oldValue = func(context.Context) (*K8sReplicaSet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sReplicaSetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sReplicaSetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sReplicaSet entities.
func (m *K8sReplicaSetMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sReplicaSetMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sReplicaSetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sReplicaSetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sReplicaSetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sReplicaSetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sReplicaSetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sReplicaSetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sReplicaSetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sReplicaSetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sReplicaSetMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sReplicaSetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sReplicaSetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sReplicaSetMutation) ResetName() {
	m.name = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sReplicaSetMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sReplicaSetMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sReplicaSetMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sReplicaSetMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sReplicaSetMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sReplicaSetMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sReplicaSetMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sReplicaSetMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sReplicaSetMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sReplicaSetMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sDeploymentId sets the "k8sDeploymentId" field.
func (m *K8sReplicaSetMutation) SetK8sDeploymentId(u uint) {
	m.k8sDeploymentId = &u
	m.addk8sDeploymentId = nil
}

// K8sDeploymentId returns the value of the "k8sDeploymentId" field in the mutation.
func (m *K8sReplicaSetMutation) K8sDeploymentId() (r uint, exists bool) {
	v := m.k8sDeploymentId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sDeploymentId returns the old "k8sDeploymentId" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldK8sDeploymentId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sDeploymentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sDeploymentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sDeploymentId: %w", err)
	}
	return oldValue.K8sDeploymentId, nil
}

// AddK8sDeploymentId adds u to the "k8sDeploymentId" field.
func (m *K8sReplicaSetMutation) AddK8sDeploymentId(u uint) {
	if m.addk8sDeploymentId != nil {
		*m.addk8sDeploymentId += u
	} else {
		m.addk8sDeploymentId = &u
	}
}

// AddedK8sDeploymentId returns the value that was added to the "k8sDeploymentId" field in this mutation.
func (m *K8sReplicaSetMutation) AddedK8sDeploymentId() (r uint, exists bool) {
	v := m.addk8sDeploymentId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sDeploymentId resets all changes to the "k8sDeploymentId" field.
func (m *K8sReplicaSetMutation) ResetK8sDeploymentId() {
	m.k8sDeploymentId = nil
	m.addk8sDeploymentId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sReplicaSetMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sReplicaSetMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sReplicaSet entity.
// If the K8sReplicaSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sReplicaSetMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sReplicaSetMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sReplicaSetMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sReplicaSetMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sReplicaSetMutation builder.
func (m *K8sReplicaSetMutation) Where(ps ...predicate.K8sReplicaSet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sReplicaSetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sReplicaSet).
func (m *K8sReplicaSetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sReplicaSetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, k8sreplicaset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sreplicaset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sreplicaset.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8sreplicaset.FieldName)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sClusterId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sNamespaceId)
	}
	if m.k8sDeploymentId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sDeploymentId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sReplicaSetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sreplicaset.FieldCreatedAt:
		return m.CreatedAt()
	case k8sreplicaset.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sreplicaset.FieldDeletedAt:
		return m.DeletedAt()
	case k8sreplicaset.FieldName:
		return m.Name()
	case k8sreplicaset.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8sreplicaset.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8sreplicaset.FieldK8sDeploymentId:
		return m.K8sDeploymentId()
	case k8sreplicaset.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sReplicaSetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sreplicaset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sreplicaset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sreplicaset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sreplicaset.FieldName:
		return m.OldName(ctx)
	case k8sreplicaset.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8sreplicaset.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8sreplicaset.FieldK8sDeploymentId:
		return m.OldK8sDeploymentId(ctx)
	case k8sreplicaset.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sReplicaSet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sReplicaSetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sreplicaset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sreplicaset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sreplicaset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sreplicaset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8sreplicaset.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8sreplicaset.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8sreplicaset.FieldK8sDeploymentId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sDeploymentId(v)
		return nil
	case k8sreplicaset.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sReplicaSet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sReplicaSetMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sClusterId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sNamespaceId)
	}
	if m.addk8sDeploymentId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sDeploymentId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8sreplicaset.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sReplicaSetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sreplicaset.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8sreplicaset.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8sreplicaset.FieldK8sDeploymentId:
		return m.AddedK8sDeploymentId()
	case k8sreplicaset.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sReplicaSetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sreplicaset.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8sreplicaset.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8sreplicaset.FieldK8sDeploymentId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sDeploymentId(v)
		return nil
	case k8sreplicaset.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sReplicaSet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sReplicaSetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sReplicaSetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sReplicaSetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sReplicaSet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sReplicaSetMutation) ResetField(name string) error {
	switch name {
	case k8sreplicaset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sreplicaset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sreplicaset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sreplicaset.FieldName:
		m.ResetName()
		return nil
	case k8sreplicaset.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8sreplicaset.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8sreplicaset.FieldK8sDeploymentId:
		m.ResetK8sDeploymentId()
		return nil
	case k8sreplicaset.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sReplicaSet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sReplicaSetMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sReplicaSetMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sReplicaSetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sReplicaSetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sReplicaSetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sReplicaSetMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sReplicaSetMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sReplicaSet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sReplicaSetMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sReplicaSet edge %s", name)
}

// K8sStatefulSetMutation represents an operation that mutates the K8sStatefulSet nodes in the graph.
type K8sStatefulSetMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	k8sClusterId      *uint
	addk8sClusterId   *uint
	k8sNamespaceId    *uint
	addk8sNamespaceId *uint
	k8sObjectId       *uint
	addk8sObjectId    *uint
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*K8sStatefulSet, error)
	predicates        []predicate.K8sStatefulSet
}

var _ ent.Mutation = (*K8sStatefulSetMutation)(nil)

// k8sstatefulsetOption allows management of the mutation configuration using functional options.
type k8sstatefulsetOption func(*K8sStatefulSetMutation)

// newK8sStatefulSetMutation creates new mutation for the K8sStatefulSet entity.
func newK8sStatefulSetMutation(c config, op Op, opts ...k8sstatefulsetOption) *K8sStatefulSetMutation {
	m := &K8sStatefulSetMutation{
		config:        c,
		op:            op,
		typ:           TypeK8sStatefulSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withK8sStatefulSetID sets the ID field of the mutation.
func withK8sStatefulSetID(id uint) k8sstatefulsetOption {
	return func(m *K8sStatefulSetMutation) {
		var (
			err   error
			once  sync.Once
			value *K8sStatefulSet
		)
		m.oldValue = func(ctx context.Context) (*K8sStatefulSet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().K8sStatefulSet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withK8sStatefulSet sets the old K8sStatefulSet of the mutation.
func withK8sStatefulSet(node *K8sStatefulSet) k8sstatefulsetOption {
	return func(m *K8sStatefulSetMutation) {
		m.oldValue = func(context.Context) (*K8sStatefulSet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m K8sStatefulSetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m K8sStatefulSetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of K8sStatefulSet entities.
func (m *K8sStatefulSetMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *K8sStatefulSetMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *K8sStatefulSetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *K8sStatefulSetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *K8sStatefulSetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *K8sStatefulSetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *K8sStatefulSetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *K8sStatefulSetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *K8sStatefulSetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *K8sStatefulSetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *K8sStatefulSetMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *K8sStatefulSetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *K8sStatefulSetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *K8sStatefulSetMutation) ResetName() {
	m.name = nil
}

// SetK8sClusterId sets the "k8sClusterId" field.
func (m *K8sStatefulSetMutation) SetK8sClusterId(u uint) {
	m.k8sClusterId = &u
	m.addk8sClusterId = nil
}

// K8sClusterId returns the value of the "k8sClusterId" field in the mutation.
func (m *K8sStatefulSetMutation) K8sClusterId() (r uint, exists bool) {
	v := m.k8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sClusterId returns the old "k8sClusterId" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldK8sClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sClusterId: %w", err)
	}
	return oldValue.K8sClusterId, nil
}

// AddK8sClusterId adds u to the "k8sClusterId" field.
func (m *K8sStatefulSetMutation) AddK8sClusterId(u uint) {
	if m.addk8sClusterId != nil {
		*m.addk8sClusterId += u
	} else {
		m.addk8sClusterId = &u
	}
}

// AddedK8sClusterId returns the value that was added to the "k8sClusterId" field in this mutation.
func (m *K8sStatefulSetMutation) AddedK8sClusterId() (r uint, exists bool) {
	v := m.addk8sClusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sClusterId resets all changes to the "k8sClusterId" field.
func (m *K8sStatefulSetMutation) ResetK8sClusterId() {
	m.k8sClusterId = nil
	m.addk8sClusterId = nil
}

// SetK8sNamespaceId sets the "k8sNamespaceId" field.
func (m *K8sStatefulSetMutation) SetK8sNamespaceId(u uint) {
	m.k8sNamespaceId = &u
	m.addk8sNamespaceId = nil
}

// K8sNamespaceId returns the value of the "k8sNamespaceId" field in the mutation.
func (m *K8sStatefulSetMutation) K8sNamespaceId() (r uint, exists bool) {
	v := m.k8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sNamespaceId returns the old "k8sNamespaceId" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldK8sNamespaceId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sNamespaceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sNamespaceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sNamespaceId: %w", err)
	}
	return oldValue.K8sNamespaceId, nil
}

// AddK8sNamespaceId adds u to the "k8sNamespaceId" field.
func (m *K8sStatefulSetMutation) AddK8sNamespaceId(u uint) {
	if m.addk8sNamespaceId != nil {
		*m.addk8sNamespaceId += u
	} else {
		m.addk8sNamespaceId = &u
	}
}

// AddedK8sNamespaceId returns the value that was added to the "k8sNamespaceId" field in this mutation.
func (m *K8sStatefulSetMutation) AddedK8sNamespaceId() (r uint, exists bool) {
	v := m.addk8sNamespaceId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sNamespaceId resets all changes to the "k8sNamespaceId" field.
func (m *K8sStatefulSetMutation) ResetK8sNamespaceId() {
	m.k8sNamespaceId = nil
	m.addk8sNamespaceId = nil
}

// SetK8sObjectId sets the "k8sObjectId" field.
func (m *K8sStatefulSetMutation) SetK8sObjectId(u uint) {
	m.k8sObjectId = &u
	m.addk8sObjectId = nil
}

// K8sObjectId returns the value of the "k8sObjectId" field in the mutation.
func (m *K8sStatefulSetMutation) K8sObjectId() (r uint, exists bool) {
	v := m.k8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// OldK8sObjectId returns the old "k8sObjectId" field's value of the K8sStatefulSet entity.
// If the K8sStatefulSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *K8sStatefulSetMutation) OldK8sObjectId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK8sObjectId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK8sObjectId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK8sObjectId: %w", err)
	}
	return oldValue.K8sObjectId, nil
}

// AddK8sObjectId adds u to the "k8sObjectId" field.
func (m *K8sStatefulSetMutation) AddK8sObjectId(u uint) {
	if m.addk8sObjectId != nil {
		*m.addk8sObjectId += u
	} else {
		m.addk8sObjectId = &u
	}
}

// AddedK8sObjectId returns the value that was added to the "k8sObjectId" field in this mutation.
func (m *K8sStatefulSetMutation) AddedK8sObjectId() (r uint, exists bool) {
	v := m.addk8sObjectId
	if v == nil {
		return
	}
	return *v, true
}

// ResetK8sObjectId resets all changes to the "k8sObjectId" field.
func (m *K8sStatefulSetMutation) ResetK8sObjectId() {
	m.k8sObjectId = nil
	m.addk8sObjectId = nil
}

// Where appends a list predicates to the K8sStatefulSetMutation builder.
func (m *K8sStatefulSetMutation) Where(ps ...predicate.K8sStatefulSet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *K8sStatefulSetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (K8sStatefulSet).
func (m *K8sStatefulSetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *K8sStatefulSetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, k8sstatefulset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, k8sstatefulset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, k8sstatefulset.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, k8sstatefulset.FieldName)
	}
	if m.k8sClusterId != nil {
		fields = append(fields, k8sstatefulset.FieldK8sClusterId)
	}
	if m.k8sNamespaceId != nil {
		fields = append(fields, k8sstatefulset.FieldK8sNamespaceId)
	}
	if m.k8sObjectId != nil {
		fields = append(fields, k8sstatefulset.FieldK8sObjectId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *K8sStatefulSetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case k8sstatefulset.FieldCreatedAt:
		return m.CreatedAt()
	case k8sstatefulset.FieldUpdatedAt:
		return m.UpdatedAt()
	case k8sstatefulset.FieldDeletedAt:
		return m.DeletedAt()
	case k8sstatefulset.FieldName:
		return m.Name()
	case k8sstatefulset.FieldK8sClusterId:
		return m.K8sClusterId()
	case k8sstatefulset.FieldK8sNamespaceId:
		return m.K8sNamespaceId()
	case k8sstatefulset.FieldK8sObjectId:
		return m.K8sObjectId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *K8sStatefulSetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case k8sstatefulset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case k8sstatefulset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case k8sstatefulset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case k8sstatefulset.FieldName:
		return m.OldName(ctx)
	case k8sstatefulset.FieldK8sClusterId:
		return m.OldK8sClusterId(ctx)
	case k8sstatefulset.FieldK8sNamespaceId:
		return m.OldK8sNamespaceId(ctx)
	case k8sstatefulset.FieldK8sObjectId:
		return m.OldK8sObjectId(ctx)
	}
	return nil, fmt.Errorf("unknown K8sStatefulSet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sStatefulSetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case k8sstatefulset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case k8sstatefulset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case k8sstatefulset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case k8sstatefulset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case k8sstatefulset.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sClusterId(v)
		return nil
	case k8sstatefulset.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sNamespaceId(v)
		return nil
	case k8sstatefulset.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sStatefulSet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *K8sStatefulSetMutation) AddedFields() []string {
	var fields []string
	if m.addk8sClusterId != nil {
		fields = append(fields, k8sstatefulset.FieldK8sClusterId)
	}
	if m.addk8sNamespaceId != nil {
		fields = append(fields, k8sstatefulset.FieldK8sNamespaceId)
	}
	if m.addk8sObjectId != nil {
		fields = append(fields, k8sstatefulset.FieldK8sObjectId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *K8sStatefulSetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case k8sstatefulset.FieldK8sClusterId:
		return m.AddedK8sClusterId()
	case k8sstatefulset.FieldK8sNamespaceId:
		return m.AddedK8sNamespaceId()
	case k8sstatefulset.FieldK8sObjectId:
		return m.AddedK8sObjectId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *K8sStatefulSetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case k8sstatefulset.FieldK8sClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sClusterId(v)
		return nil
	case k8sstatefulset.FieldK8sNamespaceId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sNamespaceId(v)
		return nil
	case k8sstatefulset.FieldK8sObjectId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK8sObjectId(v)
		return nil
	}
	return fmt.Errorf("unknown K8sStatefulSet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *K8sStatefulSetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *K8sStatefulSetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *K8sStatefulSetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown K8sStatefulSet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *K8sStatefulSetMutation) ResetField(name string) error {
	switch name {
	case k8sstatefulset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case k8sstatefulset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case k8sstatefulset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case k8sstatefulset.FieldName:
		m.ResetName()
		return nil
	case k8sstatefulset.FieldK8sClusterId:
		m.ResetK8sClusterId()
		return nil
	case k8sstatefulset.FieldK8sNamespaceId:
		m.ResetK8sNamespaceId()
		return nil
	case k8sstatefulset.FieldK8sObjectId:
		m.ResetK8sObjectId()
		return nil
	}
	return fmt.Errorf("unknown K8sStatefulSet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *K8sStatefulSetMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *K8sStatefulSetMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *K8sStatefulSetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *K8sStatefulSetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *K8sStatefulSetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *K8sStatefulSetMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *K8sStatefulSetMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown K8sStatefulSet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *K8sStatefulSetMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown K8sStatefulSet edge %s", name)
}

// MetricMutation represents an operation that mutates the Metric nodes in the graph.
type MetricMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	ts                             *time.Time
	value                          *float64
	addvalue                       *float64
	endpointId                     *uint
	addendpointId                  *uint
	typeId                         *uint
	addtypeId                      *uint
	nameId                         *uint
	addnameId                      *uint
	labelId                        *uint
	addlabelId                     *uint
	clusterId                      *uint
	addclusterId                   *uint
	nodeId                         *uint
	addnodeId                      *uint
	procesId                       *uint
	addprocesId                    *uint
	containerId                    *uint
	addcontainerId                 *uint
	clearedFields                  map[string]struct{}
	_MetricName_Metrics            *uint
	cleared_MetricName_Metrics     bool
	_MetricEndpoint_Metrics        *uint
	cleared_MetricEndpoint_Metrics bool
	_MetricLabel_Metrics           *uint
	cleared_MetricLabel_Metrics    bool
	done                           bool
	oldValue                       func(context.Context) (*Metric, error)
	predicates                     []predicate.Metric
}

var _ ent.Mutation = (*MetricMutation)(nil)

// metricOption allows management of the mutation configuration using functional options.
type metricOption func(*MetricMutation)

// newMetricMutation creates new mutation for the Metric entity.
func newMetricMutation(c config, op Op, opts ...metricOption) *MetricMutation {
	m := &MetricMutation{
		config:        c,
		op:            op,
		typ:           TypeMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricID sets the ID field of the mutation.
func withMetricID(id int) metricOption {
	return func(m *MetricMutation) {
		var (
			err   error
			once  sync.Once
			value *Metric
		)
		m.oldValue = func(ctx context.Context) (*Metric, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetric sets the old Metric of the mutation.
func withMetric(node *Metric) metricOption {
	return func(m *MetricMutation) {
		m.oldValue = func(context.Context) (*Metric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetricMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetricMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetricMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTs sets the "ts" field.
func (m *MetricMutation) SetTs(t time.Time) {
	m.ts = &t
}

// Ts returns the value of the "ts" field in the mutation.
func (m *MetricMutation) Ts() (r time.Time, exists bool) {
	v := m.ts
	if v == nil {
		return
	}
	return *v, true
}

// OldTs returns the old "ts" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldTs(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTs: %w", err)
	}
	return oldValue.Ts, nil
}

// ResetTs resets all changes to the "ts" field.
func (m *MetricMutation) ResetTs() {
	m.ts = nil
}

// SetValue sets the "value" field.
func (m *MetricMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *MetricMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *MetricMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *MetricMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *MetricMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetEndpointId sets the "endpointId" field.
func (m *MetricMutation) SetEndpointId(u uint) {
	m.endpointId = &u
	m.addendpointId = nil
}

// EndpointId returns the value of the "endpointId" field in the mutation.
func (m *MetricMutation) EndpointId() (r uint, exists bool) {
	v := m.endpointId
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointId returns the old "endpointId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldEndpointId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndpointId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndpointId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointId: %w", err)
	}
	return oldValue.EndpointId, nil
}

// AddEndpointId adds u to the "endpointId" field.
func (m *MetricMutation) AddEndpointId(u uint) {
	if m.addendpointId != nil {
		*m.addendpointId += u
	} else {
		m.addendpointId = &u
	}
}

// AddedEndpointId returns the value that was added to the "endpointId" field in this mutation.
func (m *MetricMutation) AddedEndpointId() (r uint, exists bool) {
	v := m.addendpointId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndpointId resets all changes to the "endpointId" field.
func (m *MetricMutation) ResetEndpointId() {
	m.endpointId = nil
	m.addendpointId = nil
}

// SetTypeId sets the "typeId" field.
func (m *MetricMutation) SetTypeId(u uint) {
	m.typeId = &u
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *MetricMutation) TypeId() (r uint, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldTypeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds u to the "typeId" field.
func (m *MetricMutation) AddTypeId(u uint) {
	if m.addtypeId != nil {
		*m.addtypeId += u
	} else {
		m.addtypeId = &u
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *MetricMutation) AddedTypeId() (r uint, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *MetricMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// SetNameId sets the "nameId" field.
func (m *MetricMutation) SetNameId(u uint) {
	m.nameId = &u
	m.addnameId = nil
}

// NameId returns the value of the "nameId" field in the mutation.
func (m *MetricMutation) NameId() (r uint, exists bool) {
	v := m.nameId
	if v == nil {
		return
	}
	return *v, true
}

// OldNameId returns the old "nameId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldNameId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNameId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNameId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameId: %w", err)
	}
	return oldValue.NameId, nil
}

// AddNameId adds u to the "nameId" field.
func (m *MetricMutation) AddNameId(u uint) {
	if m.addnameId != nil {
		*m.addnameId += u
	} else {
		m.addnameId = &u
	}
}

// AddedNameId returns the value that was added to the "nameId" field in this mutation.
func (m *MetricMutation) AddedNameId() (r uint, exists bool) {
	v := m.addnameId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNameId resets all changes to the "nameId" field.
func (m *MetricMutation) ResetNameId() {
	m.nameId = nil
	m.addnameId = nil
}

// SetLabelId sets the "labelId" field.
func (m *MetricMutation) SetLabelId(u uint) {
	m.labelId = &u
	m.addlabelId = nil
}

// LabelId returns the value of the "labelId" field in the mutation.
func (m *MetricMutation) LabelId() (r uint, exists bool) {
	v := m.labelId
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelId returns the old "labelId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldLabelId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelId: %w", err)
	}
	return oldValue.LabelId, nil
}

// AddLabelId adds u to the "labelId" field.
func (m *MetricMutation) AddLabelId(u uint) {
	if m.addlabelId != nil {
		*m.addlabelId += u
	} else {
		m.addlabelId = &u
	}
}

// AddedLabelId returns the value that was added to the "labelId" field in this mutation.
func (m *MetricMutation) AddedLabelId() (r uint, exists bool) {
	v := m.addlabelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetLabelId resets all changes to the "labelId" field.
func (m *MetricMutation) ResetLabelId() {
	m.labelId = nil
	m.addlabelId = nil
}

// SetClusterId sets the "clusterId" field.
func (m *MetricMutation) SetClusterId(u uint) {
	m.clusterId = &u
	m.addclusterId = nil
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *MetricMutation) ClusterId() (r uint, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// AddClusterId adds u to the "clusterId" field.
func (m *MetricMutation) AddClusterId(u uint) {
	if m.addclusterId != nil {
		*m.addclusterId += u
	} else {
		m.addclusterId = &u
	}
}

// AddedClusterId returns the value that was added to the "clusterId" field in this mutation.
func (m *MetricMutation) AddedClusterId() (r uint, exists bool) {
	v := m.addclusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *MetricMutation) ResetClusterId() {
	m.clusterId = nil
	m.addclusterId = nil
}

// SetNodeId sets the "nodeId" field.
func (m *MetricMutation) SetNodeId(u uint) {
	m.nodeId = &u
	m.addnodeId = nil
}

// NodeId returns the value of the "nodeId" field in the mutation.
func (m *MetricMutation) NodeId() (r uint, exists bool) {
	v := m.nodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeId returns the old "nodeId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldNodeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeId: %w", err)
	}
	return oldValue.NodeId, nil
}

// AddNodeId adds u to the "nodeId" field.
func (m *MetricMutation) AddNodeId(u uint) {
	if m.addnodeId != nil {
		*m.addnodeId += u
	} else {
		m.addnodeId = &u
	}
}

// AddedNodeId returns the value that was added to the "nodeId" field in this mutation.
func (m *MetricMutation) AddedNodeId() (r uint, exists bool) {
	v := m.addnodeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeId resets all changes to the "nodeId" field.
func (m *MetricMutation) ResetNodeId() {
	m.nodeId = nil
	m.addnodeId = nil
}

// SetProcesId sets the "procesId" field.
func (m *MetricMutation) SetProcesId(u uint) {
	m.procesId = &u
	m.addprocesId = nil
}

// ProcesId returns the value of the "procesId" field in the mutation.
func (m *MetricMutation) ProcesId() (r uint, exists bool) {
	v := m.procesId
	if v == nil {
		return
	}
	return *v, true
}

// OldProcesId returns the old "procesId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldProcesId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProcesId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProcesId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcesId: %w", err)
	}
	return oldValue.ProcesId, nil
}

// AddProcesId adds u to the "procesId" field.
func (m *MetricMutation) AddProcesId(u uint) {
	if m.addprocesId != nil {
		*m.addprocesId += u
	} else {
		m.addprocesId = &u
	}
}

// AddedProcesId returns the value that was added to the "procesId" field in this mutation.
func (m *MetricMutation) AddedProcesId() (r uint, exists bool) {
	v := m.addprocesId
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcesId resets all changes to the "procesId" field.
func (m *MetricMutation) ResetProcesId() {
	m.procesId = nil
	m.addprocesId = nil
}

// SetContainerId sets the "containerId" field.
func (m *MetricMutation) SetContainerId(u uint) {
	m.containerId = &u
	m.addcontainerId = nil
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *MetricMutation) ContainerId() (r uint, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldContainerId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// AddContainerId adds u to the "containerId" field.
func (m *MetricMutation) AddContainerId(u uint) {
	if m.addcontainerId != nil {
		*m.addcontainerId += u
	} else {
		m.addcontainerId = &u
	}
}

// AddedContainerId returns the value that was added to the "containerId" field in this mutation.
func (m *MetricMutation) AddedContainerId() (r uint, exists bool) {
	v := m.addcontainerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *MetricMutation) ResetContainerId() {
	m.containerId = nil
	m.addcontainerId = nil
}

// SetMetricNameMetricsID sets the "MetricName_Metrics" edge to the MetricName entity by id.
func (m *MetricMutation) SetMetricNameMetricsID(id uint) {
	m._MetricName_Metrics = &id
}

// ClearMetricNameMetrics clears the "MetricName_Metrics" edge to the MetricName entity.
func (m *MetricMutation) ClearMetricNameMetrics() {
	m.cleared_MetricName_Metrics = true
}

// MetricNameMetricsCleared reports if the "MetricName_Metrics" edge to the MetricName entity was cleared.
func (m *MetricMutation) MetricNameMetricsCleared() bool {
	return m.cleared_MetricName_Metrics
}

// MetricNameMetricsID returns the "MetricName_Metrics" edge ID in the mutation.
func (m *MetricMutation) MetricNameMetricsID() (id uint, exists bool) {
	if m._MetricName_Metrics != nil {
		return *m._MetricName_Metrics, true
	}
	return
}

// MetricNameMetricsIDs returns the "MetricName_Metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricNameMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricMutation) MetricNameMetricsIDs() (ids []uint) {
	if id := m._MetricName_Metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetricNameMetrics resets all changes to the "MetricName_Metrics" edge.
func (m *MetricMutation) ResetMetricNameMetrics() {
	m._MetricName_Metrics = nil
	m.cleared_MetricName_Metrics = false
}

// SetMetricEndpointMetricsID sets the "MetricEndpoint_Metrics" edge to the MetricEndpoint entity by id.
func (m *MetricMutation) SetMetricEndpointMetricsID(id uint) {
	m._MetricEndpoint_Metrics = &id
}

// ClearMetricEndpointMetrics clears the "MetricEndpoint_Metrics" edge to the MetricEndpoint entity.
func (m *MetricMutation) ClearMetricEndpointMetrics() {
	m.cleared_MetricEndpoint_Metrics = true
}

// MetricEndpointMetricsCleared reports if the "MetricEndpoint_Metrics" edge to the MetricEndpoint entity was cleared.
func (m *MetricMutation) MetricEndpointMetricsCleared() bool {
	return m.cleared_MetricEndpoint_Metrics
}

// MetricEndpointMetricsID returns the "MetricEndpoint_Metrics" edge ID in the mutation.
func (m *MetricMutation) MetricEndpointMetricsID() (id uint, exists bool) {
	if m._MetricEndpoint_Metrics != nil {
		return *m._MetricEndpoint_Metrics, true
	}
	return
}

// MetricEndpointMetricsIDs returns the "MetricEndpoint_Metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricEndpointMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricMutation) MetricEndpointMetricsIDs() (ids []uint) {
	if id := m._MetricEndpoint_Metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetricEndpointMetrics resets all changes to the "MetricEndpoint_Metrics" edge.
func (m *MetricMutation) ResetMetricEndpointMetrics() {
	m._MetricEndpoint_Metrics = nil
	m.cleared_MetricEndpoint_Metrics = false
}

// SetMetricLabelMetricsID sets the "MetricLabel_Metrics" edge to the MetricLabel entity by id.
func (m *MetricMutation) SetMetricLabelMetricsID(id uint) {
	m._MetricLabel_Metrics = &id
}

// ClearMetricLabelMetrics clears the "MetricLabel_Metrics" edge to the MetricLabel entity.
func (m *MetricMutation) ClearMetricLabelMetrics() {
	m.cleared_MetricLabel_Metrics = true
}

// MetricLabelMetricsCleared reports if the "MetricLabel_Metrics" edge to the MetricLabel entity was cleared.
func (m *MetricMutation) MetricLabelMetricsCleared() bool {
	return m.cleared_MetricLabel_Metrics
}

// MetricLabelMetricsID returns the "MetricLabel_Metrics" edge ID in the mutation.
func (m *MetricMutation) MetricLabelMetricsID() (id uint, exists bool) {
	if m._MetricLabel_Metrics != nil {
		return *m._MetricLabel_Metrics, true
	}
	return
}

// MetricLabelMetricsIDs returns the "MetricLabel_Metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricLabelMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricMutation) MetricLabelMetricsIDs() (ids []uint) {
	if id := m._MetricLabel_Metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetricLabelMetrics resets all changes to the "MetricLabel_Metrics" edge.
func (m *MetricMutation) ResetMetricLabelMetrics() {
	m._MetricLabel_Metrics = nil
	m.cleared_MetricLabel_Metrics = false
}

// Where appends a list predicates to the MetricMutation builder.
func (m *MetricMutation) Where(ps ...predicate.Metric) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetricMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Metric).
func (m *MetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, metric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metric.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, metric.FieldDeletedAt)
	}
	if m.ts != nil {
		fields = append(fields, metric.FieldTs)
	}
	if m.value != nil {
		fields = append(fields, metric.FieldValue)
	}
	if m.endpointId != nil {
		fields = append(fields, metric.FieldEndpointId)
	}
	if m.typeId != nil {
		fields = append(fields, metric.FieldTypeId)
	}
	if m.nameId != nil {
		fields = append(fields, metric.FieldNameId)
	}
	if m.labelId != nil {
		fields = append(fields, metric.FieldLabelId)
	}
	if m.clusterId != nil {
		fields = append(fields, metric.FieldClusterId)
	}
	if m.nodeId != nil {
		fields = append(fields, metric.FieldNodeId)
	}
	if m.procesId != nil {
		fields = append(fields, metric.FieldProcesId)
	}
	if m.containerId != nil {
		fields = append(fields, metric.FieldContainerId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metric.FieldCreatedAt:
		return m.CreatedAt()
	case metric.FieldUpdatedAt:
		return m.UpdatedAt()
	case metric.FieldDeletedAt:
		return m.DeletedAt()
	case metric.FieldTs:
		return m.Ts()
	case metric.FieldValue:
		return m.Value()
	case metric.FieldEndpointId:
		return m.EndpointId()
	case metric.FieldTypeId:
		return m.TypeId()
	case metric.FieldNameId:
		return m.NameId()
	case metric.FieldLabelId:
		return m.LabelId()
	case metric.FieldClusterId:
		return m.ClusterId()
	case metric.FieldNodeId:
		return m.NodeId()
	case metric.FieldProcesId:
		return m.ProcesId()
	case metric.FieldContainerId:
		return m.ContainerId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metric.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metric.FieldTs:
		return m.OldTs(ctx)
	case metric.FieldValue:
		return m.OldValue(ctx)
	case metric.FieldEndpointId:
		return m.OldEndpointId(ctx)
	case metric.FieldTypeId:
		return m.OldTypeId(ctx)
	case metric.FieldNameId:
		return m.OldNameId(ctx)
	case metric.FieldLabelId:
		return m.OldLabelId(ctx)
	case metric.FieldClusterId:
		return m.OldClusterId(ctx)
	case metric.FieldNodeId:
		return m.OldNodeId(ctx)
	case metric.FieldProcesId:
		return m.OldProcesId(ctx)
	case metric.FieldContainerId:
		return m.OldContainerId(ctx)
	}
	return nil, fmt.Errorf("unknown Metric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metric.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metric.FieldTs:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTs(v)
		return nil
	case metric.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case metric.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointId(v)
		return nil
	case metric.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case metric.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameId(v)
		return nil
	case metric.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelId(v)
		return nil
	case metric.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	case metric.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeId(v)
		return nil
	case metric.FieldProcesId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcesId(v)
		return nil
	case metric.FieldContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	}
	return fmt.Errorf("unknown Metric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, metric.FieldValue)
	}
	if m.addendpointId != nil {
		fields = append(fields, metric.FieldEndpointId)
	}
	if m.addtypeId != nil {
		fields = append(fields, metric.FieldTypeId)
	}
	if m.addnameId != nil {
		fields = append(fields, metric.FieldNameId)
	}
	if m.addlabelId != nil {
		fields = append(fields, metric.FieldLabelId)
	}
	if m.addclusterId != nil {
		fields = append(fields, metric.FieldClusterId)
	}
	if m.addnodeId != nil {
		fields = append(fields, metric.FieldNodeId)
	}
	if m.addprocesId != nil {
		fields = append(fields, metric.FieldProcesId)
	}
	if m.addcontainerId != nil {
		fields = append(fields, metric.FieldContainerId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metric.FieldValue:
		return m.AddedValue()
	case metric.FieldEndpointId:
		return m.AddedEndpointId()
	case metric.FieldTypeId:
		return m.AddedTypeId()
	case metric.FieldNameId:
		return m.AddedNameId()
	case metric.FieldLabelId:
		return m.AddedLabelId()
	case metric.FieldClusterId:
		return m.AddedClusterId()
	case metric.FieldNodeId:
		return m.AddedNodeId()
	case metric.FieldProcesId:
		return m.AddedProcesId()
	case metric.FieldContainerId:
		return m.AddedContainerId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metric.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case metric.FieldEndpointId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndpointId(v)
		return nil
	case metric.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case metric.FieldNameId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNameId(v)
		return nil
	case metric.FieldLabelId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLabelId(v)
		return nil
	case metric.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClusterId(v)
		return nil
	case metric.FieldNodeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeId(v)
		return nil
	case metric.FieldProcesId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcesId(v)
		return nil
	case metric.FieldContainerId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContainerId(v)
		return nil
	}
	return fmt.Errorf("unknown Metric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricMutation) ResetField(name string) error {
	switch name {
	case metric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metric.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metric.FieldTs:
		m.ResetTs()
		return nil
	case metric.FieldValue:
		m.ResetValue()
		return nil
	case metric.FieldEndpointId:
		m.ResetEndpointId()
		return nil
	case metric.FieldTypeId:
		m.ResetTypeId()
		return nil
	case metric.FieldNameId:
		m.ResetNameId()
		return nil
	case metric.FieldLabelId:
		m.ResetLabelId()
		return nil
	case metric.FieldClusterId:
		m.ResetClusterId()
		return nil
	case metric.FieldNodeId:
		m.ResetNodeId()
		return nil
	case metric.FieldProcesId:
		m.ResetProcesId()
		return nil
	case metric.FieldContainerId:
		m.ResetContainerId()
		return nil
	}
	return fmt.Errorf("unknown Metric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._MetricName_Metrics != nil {
		edges = append(edges, metric.EdgeMetricNameMetrics)
	}
	if m._MetricEndpoint_Metrics != nil {
		edges = append(edges, metric.EdgeMetricEndpointMetrics)
	}
	if m._MetricLabel_Metrics != nil {
		edges = append(edges, metric.EdgeMetricLabelMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metric.EdgeMetricNameMetrics:
		if id := m._MetricName_Metrics; id != nil {
			return []ent.Value{*id}
		}
	case metric.EdgeMetricEndpointMetrics:
		if id := m._MetricEndpoint_Metrics; id != nil {
			return []ent.Value{*id}
		}
	case metric.EdgeMetricLabelMetrics:
		if id := m._MetricLabel_Metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_MetricName_Metrics {
		edges = append(edges, metric.EdgeMetricNameMetrics)
	}
	if m.cleared_MetricEndpoint_Metrics {
		edges = append(edges, metric.EdgeMetricEndpointMetrics)
	}
	if m.cleared_MetricLabel_Metrics {
		edges = append(edges, metric.EdgeMetricLabelMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricMutation) EdgeCleared(name string) bool {
	switch name {
	case metric.EdgeMetricNameMetrics:
		return m.cleared_MetricName_Metrics
	case metric.EdgeMetricEndpointMetrics:
		return m.cleared_MetricEndpoint_Metrics
	case metric.EdgeMetricLabelMetrics:
		return m.cleared_MetricLabel_Metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricMutation) ClearEdge(name string) error {
	switch name {
	case metric.EdgeMetricNameMetrics:
		m.ClearMetricNameMetrics()
		return nil
	case metric.EdgeMetricEndpointMetrics:
		m.ClearMetricEndpointMetrics()
		return nil
	case metric.EdgeMetricLabelMetrics:
		m.ClearMetricLabelMetrics()
		return nil
	}
	return fmt.Errorf("unknown Metric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricMutation) ResetEdge(name string) error {
	switch name {
	case metric.EdgeMetricNameMetrics:
		m.ResetMetricNameMetrics()
		return nil
	case metric.EdgeMetricEndpointMetrics:
		m.ResetMetricEndpointMetrics()
		return nil
	case metric.EdgeMetricLabelMetrics:
		m.ResetMetricLabelMetrics()
		return nil
	}
	return fmt.Errorf("unknown Metric edge %s", name)
}

// MetricEndpointMutation represents an operation that mutates the MetricEndpoint nodes in the graph.
type MetricEndpointMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	_path          *string
	clearedFields  map[string]struct{}
	metrics        map[int]struct{}
	removedmetrics map[int]struct{}
	clearedmetrics bool
	events         map[int]struct{}
	removedevents  map[int]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*MetricEndpoint, error)
	predicates     []predicate.MetricEndpoint
}

var _ ent.Mutation = (*MetricEndpointMutation)(nil)

// metricendpointOption allows management of the mutation configuration using functional options.
type metricendpointOption func(*MetricEndpointMutation)

// newMetricEndpointMutation creates new mutation for the MetricEndpoint entity.
func newMetricEndpointMutation(c config, op Op, opts ...metricendpointOption) *MetricEndpointMutation {
	m := &MetricEndpointMutation{
		config:        c,
		op:            op,
		typ:           TypeMetricEndpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricEndpointID sets the ID field of the mutation.
func withMetricEndpointID(id uint) metricendpointOption {
	return func(m *MetricEndpointMutation) {
		var (
			err   error
			once  sync.Once
			value *MetricEndpoint
		)
		m.oldValue = func(ctx context.Context) (*MetricEndpoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetricEndpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetricEndpoint sets the old MetricEndpoint of the mutation.
func withMetricEndpoint(node *MetricEndpoint) metricendpointOption {
	return func(m *MetricEndpointMutation) {
		m.oldValue = func(context.Context) (*MetricEndpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricEndpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricEndpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MetricEndpoint entities.
func (m *MetricEndpointMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricEndpointMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricEndpointMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricEndpointMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MetricEndpoint entity.
// If the MetricEndpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricEndpointMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricEndpointMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricEndpointMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricEndpointMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MetricEndpoint entity.
// If the MetricEndpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricEndpointMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricEndpointMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetricEndpointMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetricEndpointMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MetricEndpoint entity.
// If the MetricEndpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricEndpointMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetricEndpointMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetPath sets the "path" field.
func (m *MetricEndpointMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MetricEndpointMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the MetricEndpoint entity.
// If the MetricEndpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricEndpointMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *MetricEndpointMutation) ResetPath() {
	m._path = nil
}

// AddMetricIDs adds the "metrics" edge to the Metric entity by ids.
func (m *MetricEndpointMutation) AddMetricIDs(ids ...int) {
	if m.metrics == nil {
		m.metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.metrics[ids[i]] = struct{}{}
	}
}

// ClearMetrics clears the "metrics" edge to the Metric entity.
func (m *MetricEndpointMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metric entity was cleared.
func (m *MetricEndpointMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// RemoveMetricIDs removes the "metrics" edge to the Metric entity by IDs.
func (m *MetricEndpointMutation) RemoveMetricIDs(ids ...int) {
	if m.removedmetrics == nil {
		m.removedmetrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metrics, ids[i])
		m.removedmetrics[ids[i]] = struct{}{}
	}
}

// RemovedMetrics returns the removed IDs of the "metrics" edge to the Metric entity.
func (m *MetricEndpointMutation) RemovedMetricsIDs() (ids []int) {
	for id := range m.removedmetrics {
		ids = append(ids, id)
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
func (m *MetricEndpointMutation) MetricsIDs() (ids []int) {
	for id := range m.metrics {
		ids = append(ids, id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *MetricEndpointMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
	m.removedmetrics = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *MetricEndpointMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *MetricEndpointMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *MetricEndpointMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *MetricEndpointMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *MetricEndpointMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *MetricEndpointMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *MetricEndpointMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the MetricEndpointMutation builder.
func (m *MetricEndpointMutation) Where(ps ...predicate.MetricEndpoint) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetricEndpointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MetricEndpoint).
func (m *MetricEndpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricEndpointMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, metricendpoint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metricendpoint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, metricendpoint.FieldDeletedAt)
	}
	if m._path != nil {
		fields = append(fields, metricendpoint.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricEndpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metricendpoint.FieldCreatedAt:
		return m.CreatedAt()
	case metricendpoint.FieldUpdatedAt:
		return m.UpdatedAt()
	case metricendpoint.FieldDeletedAt:
		return m.DeletedAt()
	case metricendpoint.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricEndpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metricendpoint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metricendpoint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metricendpoint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metricendpoint.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown MetricEndpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricEndpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metricendpoint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metricendpoint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metricendpoint.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metricendpoint.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown MetricEndpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricEndpointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricEndpointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricEndpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricEndpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricEndpointMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricEndpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricEndpointMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetricEndpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricEndpointMutation) ResetField(name string) error {
	switch name {
	case metricendpoint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metricendpoint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metricendpoint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metricendpoint.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown MetricEndpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricEndpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metrics != nil {
		edges = append(edges, metricendpoint.EdgeMetrics)
	}
	if m.events != nil {
		edges = append(edges, metricendpoint.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricEndpointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metricendpoint.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.metrics))
		for id := range m.metrics {
			ids = append(ids, id)
		}
		return ids
	case metricendpoint.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricEndpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmetrics != nil {
		edges = append(edges, metricendpoint.EdgeMetrics)
	}
	if m.removedevents != nil {
		edges = append(edges, metricendpoint.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricEndpointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metricendpoint.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.removedmetrics))
		for id := range m.removedmetrics {
			ids = append(ids, id)
		}
		return ids
	case metricendpoint.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricEndpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetrics {
		edges = append(edges, metricendpoint.EdgeMetrics)
	}
	if m.clearedevents {
		edges = append(edges, metricendpoint.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricEndpointMutation) EdgeCleared(name string) bool {
	switch name {
	case metricendpoint.EdgeMetrics:
		return m.clearedmetrics
	case metricendpoint.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricEndpointMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricEndpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricEndpointMutation) ResetEdge(name string) error {
	switch name {
	case metricendpoint.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case metricendpoint.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown MetricEndpoint edge %s", name)
}

// MetricLabelMutation represents an operation that mutates the MetricLabel nodes in the graph.
type MetricLabelMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	label          *string
	clearedFields  map[string]struct{}
	metrics        map[int]struct{}
	removedmetrics map[int]struct{}
	clearedmetrics bool
	events         map[int]struct{}
	removedevents  map[int]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*MetricLabel, error)
	predicates     []predicate.MetricLabel
}

var _ ent.Mutation = (*MetricLabelMutation)(nil)

// metriclabelOption allows management of the mutation configuration using functional options.
type metriclabelOption func(*MetricLabelMutation)

// newMetricLabelMutation creates new mutation for the MetricLabel entity.
func newMetricLabelMutation(c config, op Op, opts ...metriclabelOption) *MetricLabelMutation {
	m := &MetricLabelMutation{
		config:        c,
		op:            op,
		typ:           TypeMetricLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricLabelID sets the ID field of the mutation.
func withMetricLabelID(id uint) metriclabelOption {
	return func(m *MetricLabelMutation) {
		var (
			err   error
			once  sync.Once
			value *MetricLabel
		)
		m.oldValue = func(ctx context.Context) (*MetricLabel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetricLabel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetricLabel sets the old MetricLabel of the mutation.
func withMetricLabel(node *MetricLabel) metriclabelOption {
	return func(m *MetricLabelMutation) {
		m.oldValue = func(context.Context) (*MetricLabel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricLabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricLabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MetricLabel entities.
func (m *MetricLabelMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricLabelMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricLabelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricLabelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MetricLabel entity.
// If the MetricLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricLabelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricLabelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricLabelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricLabelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MetricLabel entity.
// If the MetricLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricLabelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricLabelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetricLabelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetricLabelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MetricLabel entity.
// If the MetricLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricLabelMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetricLabelMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetLabel sets the "label" field.
func (m *MetricLabelMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *MetricLabelMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the MetricLabel entity.
// If the MetricLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricLabelMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *MetricLabelMutation) ResetLabel() {
	m.label = nil
}

// AddMetricIDs adds the "metrics" edge to the Metric entity by ids.
func (m *MetricLabelMutation) AddMetricIDs(ids ...int) {
	if m.metrics == nil {
		m.metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.metrics[ids[i]] = struct{}{}
	}
}

// ClearMetrics clears the "metrics" edge to the Metric entity.
func (m *MetricLabelMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metric entity was cleared.
func (m *MetricLabelMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// RemoveMetricIDs removes the "metrics" edge to the Metric entity by IDs.
func (m *MetricLabelMutation) RemoveMetricIDs(ids ...int) {
	if m.removedmetrics == nil {
		m.removedmetrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metrics, ids[i])
		m.removedmetrics[ids[i]] = struct{}{}
	}
}

// RemovedMetrics returns the removed IDs of the "metrics" edge to the Metric entity.
func (m *MetricLabelMutation) RemovedMetricsIDs() (ids []int) {
	for id := range m.removedmetrics {
		ids = append(ids, id)
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
func (m *MetricLabelMutation) MetricsIDs() (ids []int) {
	for id := range m.metrics {
		ids = append(ids, id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *MetricLabelMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
	m.removedmetrics = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *MetricLabelMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *MetricLabelMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *MetricLabelMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *MetricLabelMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *MetricLabelMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *MetricLabelMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *MetricLabelMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the MetricLabelMutation builder.
func (m *MetricLabelMutation) Where(ps ...predicate.MetricLabel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetricLabelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MetricLabel).
func (m *MetricLabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricLabelMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, metriclabel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metriclabel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, metriclabel.FieldDeletedAt)
	}
	if m.label != nil {
		fields = append(fields, metriclabel.FieldLabel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricLabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metriclabel.FieldCreatedAt:
		return m.CreatedAt()
	case metriclabel.FieldUpdatedAt:
		return m.UpdatedAt()
	case metriclabel.FieldDeletedAt:
		return m.DeletedAt()
	case metriclabel.FieldLabel:
		return m.Label()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricLabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metriclabel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metriclabel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metriclabel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metriclabel.FieldLabel:
		return m.OldLabel(ctx)
	}
	return nil, fmt.Errorf("unknown MetricLabel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricLabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metriclabel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metriclabel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metriclabel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metriclabel.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	}
	return fmt.Errorf("unknown MetricLabel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricLabelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricLabelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricLabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricLabel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricLabelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricLabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricLabelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetricLabel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricLabelMutation) ResetField(name string) error {
	switch name {
	case metriclabel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metriclabel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metriclabel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metriclabel.FieldLabel:
		m.ResetLabel()
		return nil
	}
	return fmt.Errorf("unknown MetricLabel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricLabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metrics != nil {
		edges = append(edges, metriclabel.EdgeMetrics)
	}
	if m.events != nil {
		edges = append(edges, metriclabel.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricLabelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metriclabel.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.metrics))
		for id := range m.metrics {
			ids = append(ids, id)
		}
		return ids
	case metriclabel.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricLabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmetrics != nil {
		edges = append(edges, metriclabel.EdgeMetrics)
	}
	if m.removedevents != nil {
		edges = append(edges, metriclabel.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricLabelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metriclabel.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.removedmetrics))
		for id := range m.removedmetrics {
			ids = append(ids, id)
		}
		return ids
	case metriclabel.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricLabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetrics {
		edges = append(edges, metriclabel.EdgeMetrics)
	}
	if m.clearedevents {
		edges = append(edges, metriclabel.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricLabelMutation) EdgeCleared(name string) bool {
	switch name {
	case metriclabel.EdgeMetrics:
		return m.clearedmetrics
	case metriclabel.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricLabelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricLabel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricLabelMutation) ResetEdge(name string) error {
	switch name {
	case metriclabel.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case metriclabel.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown MetricLabel edge %s", name)
}

// MetricNameMutation represents an operation that mutates the MetricName nodes in the graph.
type MetricNameMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	name           *string
	help           *string
	typeId         *uint
	addtypeId      *uint
	clearedFields  map[string]struct{}
	metrics        map[int]struct{}
	removedmetrics map[int]struct{}
	clearedmetrics bool
	events         map[int]struct{}
	removedevents  map[int]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*MetricName, error)
	predicates     []predicate.MetricName
}

var _ ent.Mutation = (*MetricNameMutation)(nil)

// metricnameOption allows management of the mutation configuration using functional options.
type metricnameOption func(*MetricNameMutation)

// newMetricNameMutation creates new mutation for the MetricName entity.
func newMetricNameMutation(c config, op Op, opts ...metricnameOption) *MetricNameMutation {
	m := &MetricNameMutation{
		config:        c,
		op:            op,
		typ:           TypeMetricName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricNameID sets the ID field of the mutation.
func withMetricNameID(id uint) metricnameOption {
	return func(m *MetricNameMutation) {
		var (
			err   error
			once  sync.Once
			value *MetricName
		)
		m.oldValue = func(ctx context.Context) (*MetricName, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetricName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetricName sets the old MetricName of the mutation.
func withMetricName(node *MetricName) metricnameOption {
	return func(m *MetricNameMutation) {
		m.oldValue = func(context.Context) (*MetricName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MetricName entities.
func (m *MetricNameMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricNameMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricNameMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricNameMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MetricName entity.
// If the MetricName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricNameMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricNameMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricNameMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricNameMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MetricName entity.
// If the MetricName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricNameMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricNameMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetricNameMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetricNameMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MetricName entity.
// If the MetricName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricNameMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetricNameMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *MetricNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MetricNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MetricName entity.
// If the MetricName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MetricNameMutation) ResetName() {
	m.name = nil
}

// SetHelp sets the "help" field.
func (m *MetricNameMutation) SetHelp(s string) {
	m.help = &s
}

// Help returns the value of the "help" field in the mutation.
func (m *MetricNameMutation) Help() (r string, exists bool) {
	v := m.help
	if v == nil {
		return
	}
	return *v, true
}

// OldHelp returns the old "help" field's value of the MetricName entity.
// If the MetricName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricNameMutation) OldHelp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHelp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHelp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHelp: %w", err)
	}
	return oldValue.Help, nil
}

// ResetHelp resets all changes to the "help" field.
func (m *MetricNameMutation) ResetHelp() {
	m.help = nil
}

// SetTypeId sets the "typeId" field.
func (m *MetricNameMutation) SetTypeId(u uint) {
	m.typeId = &u
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *MetricNameMutation) TypeId() (r uint, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the MetricName entity.
// If the MetricName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricNameMutation) OldTypeId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds u to the "typeId" field.
func (m *MetricNameMutation) AddTypeId(u uint) {
	if m.addtypeId != nil {
		*m.addtypeId += u
	} else {
		m.addtypeId = &u
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *MetricNameMutation) AddedTypeId() (r uint, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *MetricNameMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// AddMetricIDs adds the "metrics" edge to the Metric entity by ids.
func (m *MetricNameMutation) AddMetricIDs(ids ...int) {
	if m.metrics == nil {
		m.metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.metrics[ids[i]] = struct{}{}
	}
}

// ClearMetrics clears the "metrics" edge to the Metric entity.
func (m *MetricNameMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metric entity was cleared.
func (m *MetricNameMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// RemoveMetricIDs removes the "metrics" edge to the Metric entity by IDs.
func (m *MetricNameMutation) RemoveMetricIDs(ids ...int) {
	if m.removedmetrics == nil {
		m.removedmetrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metrics, ids[i])
		m.removedmetrics[ids[i]] = struct{}{}
	}
}

// RemovedMetrics returns the removed IDs of the "metrics" edge to the Metric entity.
func (m *MetricNameMutation) RemovedMetricsIDs() (ids []int) {
	for id := range m.removedmetrics {
		ids = append(ids, id)
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
func (m *MetricNameMutation) MetricsIDs() (ids []int) {
	for id := range m.metrics {
		ids = append(ids, id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *MetricNameMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
	m.removedmetrics = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *MetricNameMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *MetricNameMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *MetricNameMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *MetricNameMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *MetricNameMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *MetricNameMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *MetricNameMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the MetricNameMutation builder.
func (m *MetricNameMutation) Where(ps ...predicate.MetricName) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetricNameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MetricName).
func (m *MetricNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricNameMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, metricname.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metricname.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, metricname.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, metricname.FieldName)
	}
	if m.help != nil {
		fields = append(fields, metricname.FieldHelp)
	}
	if m.typeId != nil {
		fields = append(fields, metricname.FieldTypeId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metricname.FieldCreatedAt:
		return m.CreatedAt()
	case metricname.FieldUpdatedAt:
		return m.UpdatedAt()
	case metricname.FieldDeletedAt:
		return m.DeletedAt()
	case metricname.FieldName:
		return m.Name()
	case metricname.FieldHelp:
		return m.Help()
	case metricname.FieldTypeId:
		return m.TypeId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metricname.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metricname.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metricname.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metricname.FieldName:
		return m.OldName(ctx)
	case metricname.FieldHelp:
		return m.OldHelp(ctx)
	case metricname.FieldTypeId:
		return m.OldTypeId(ctx)
	}
	return nil, fmt.Errorf("unknown MetricName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metricname.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metricname.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metricname.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metricname.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case metricname.FieldHelp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHelp(v)
		return nil
	case metricname.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	}
	return fmt.Errorf("unknown MetricName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricNameMutation) AddedFields() []string {
	var fields []string
	if m.addtypeId != nil {
		fields = append(fields, metricname.FieldTypeId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metricname.FieldTypeId:
		return m.AddedTypeId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metricname.FieldTypeId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	}
	return fmt.Errorf("unknown MetricName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetricName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricNameMutation) ResetField(name string) error {
	switch name {
	case metricname.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metricname.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metricname.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metricname.FieldName:
		m.ResetName()
		return nil
	case metricname.FieldHelp:
		m.ResetHelp()
		return nil
	case metricname.FieldTypeId:
		m.ResetTypeId()
		return nil
	}
	return fmt.Errorf("unknown MetricName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metrics != nil {
		edges = append(edges, metricname.EdgeMetrics)
	}
	if m.events != nil {
		edges = append(edges, metricname.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metricname.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.metrics))
		for id := range m.metrics {
			ids = append(ids, id)
		}
		return ids
	case metricname.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmetrics != nil {
		edges = append(edges, metricname.EdgeMetrics)
	}
	if m.removedevents != nil {
		edges = append(edges, metricname.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metricname.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.removedmetrics))
		for id := range m.removedmetrics {
			ids = append(ids, id)
		}
		return ids
	case metricname.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetrics {
		edges = append(edges, metricname.EdgeMetrics)
	}
	if m.clearedevents {
		edges = append(edges, metricname.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricNameMutation) EdgeCleared(name string) bool {
	switch name {
	case metricname.EdgeMetrics:
		return m.clearedmetrics
	case metricname.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricNameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricNameMutation) ResetEdge(name string) error {
	switch name {
	case metricname.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case metricname.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown MetricName edge %s", name)
}

// MetricTypeMutation represents an operation that mutates the MetricType nodes in the graph.
type MetricTypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	clearedFields      map[string]struct{}
	metricNames        map[uint]struct{}
	removedmetricNames map[uint]struct{}
	clearedmetricNames bool
	done               bool
	oldValue           func(context.Context) (*MetricType, error)
	predicates         []predicate.MetricType
}

var _ ent.Mutation = (*MetricTypeMutation)(nil)

// metrictypeOption allows management of the mutation configuration using functional options.
type metrictypeOption func(*MetricTypeMutation)

// newMetricTypeMutation creates new mutation for the MetricType entity.
func newMetricTypeMutation(c config, op Op, opts ...metrictypeOption) *MetricTypeMutation {
	m := &MetricTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMetricType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricTypeID sets the ID field of the mutation.
func withMetricTypeID(id uint) metrictypeOption {
	return func(m *MetricTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MetricType
		)
		m.oldValue = func(ctx context.Context) (*MetricType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetricType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetricType sets the old MetricType of the mutation.
func withMetricType(node *MetricType) metrictypeOption {
	return func(m *MetricTypeMutation) {
		m.oldValue = func(context.Context) (*MetricType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MetricType entities.
func (m *MetricTypeMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricTypeMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MetricType entity.
// If the MetricType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MetricType entity.
// If the MetricType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetricTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetricTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MetricType entity.
// If the MetricType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetricTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *MetricTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MetricTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MetricType entity.
// If the MetricType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MetricTypeMutation) ResetName() {
	m.name = nil
}

// AddMetricNameIDs adds the "metricNames" edge to the MetricName entity by ids.
func (m *MetricTypeMutation) AddMetricNameIDs(ids ...uint) {
	if m.metricNames == nil {
		m.metricNames = make(map[uint]struct{})
	}
	for i := range ids {
		m.metricNames[ids[i]] = struct{}{}
	}
}

// ClearMetricNames clears the "metricNames" edge to the MetricName entity.
func (m *MetricTypeMutation) ClearMetricNames() {
	m.clearedmetricNames = true
}

// MetricNamesCleared reports if the "metricNames" edge to the MetricName entity was cleared.
func (m *MetricTypeMutation) MetricNamesCleared() bool {
	return m.clearedmetricNames
}

// RemoveMetricNameIDs removes the "metricNames" edge to the MetricName entity by IDs.
func (m *MetricTypeMutation) RemoveMetricNameIDs(ids ...uint) {
	if m.removedmetricNames == nil {
		m.removedmetricNames = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.metricNames, ids[i])
		m.removedmetricNames[ids[i]] = struct{}{}
	}
}

// RemovedMetricNames returns the removed IDs of the "metricNames" edge to the MetricName entity.
func (m *MetricTypeMutation) RemovedMetricNamesIDs() (ids []uint) {
	for id := range m.removedmetricNames {
		ids = append(ids, id)
	}
	return
}

// MetricNamesIDs returns the "metricNames" edge IDs in the mutation.
func (m *MetricTypeMutation) MetricNamesIDs() (ids []uint) {
	for id := range m.metricNames {
		ids = append(ids, id)
	}
	return
}

// ResetMetricNames resets all changes to the "metricNames" edge.
func (m *MetricTypeMutation) ResetMetricNames() {
	m.metricNames = nil
	m.clearedmetricNames = false
	m.removedmetricNames = nil
}

// Where appends a list predicates to the MetricTypeMutation builder.
func (m *MetricTypeMutation) Where(ps ...predicate.MetricType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetricTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MetricType).
func (m *MetricTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, metrictype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metrictype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, metrictype.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, metrictype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metrictype.FieldCreatedAt:
		return m.CreatedAt()
	case metrictype.FieldUpdatedAt:
		return m.UpdatedAt()
	case metrictype.FieldDeletedAt:
		return m.DeletedAt()
	case metrictype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metrictype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metrictype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metrictype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metrictype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MetricType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metrictype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metrictype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metrictype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metrictype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MetricType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetricType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricTypeMutation) ResetField(name string) error {
	switch name {
	case metrictype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metrictype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metrictype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metrictype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MetricType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metricNames != nil {
		edges = append(edges, metrictype.EdgeMetricNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metrictype.EdgeMetricNames:
		ids := make([]ent.Value, 0, len(m.metricNames))
		for id := range m.metricNames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmetricNames != nil {
		edges = append(edges, metrictype.EdgeMetricNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metrictype.EdgeMetricNames:
		ids := make([]ent.Value, 0, len(m.removedmetricNames))
		for id := range m.removedmetricNames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetricNames {
		edges = append(edges, metrictype.EdgeMetricNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case metrictype.EdgeMetricNames:
		return m.clearedmetricNames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MetricType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricTypeMutation) ResetEdge(name string) error {
	switch name {
	case metrictype.EdgeMetricNames:
		m.ResetMetricNames()
		return nil
	}
	return fmt.Errorf("unknown MetricType edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	host              *string
	ipv4              *string
	ipv6              *string
	public_ipv4       *string
	public_ipv6       *string
	os                *string
	platform          *string
	platformFamily    *string
	info              *[]string
	uuid              *string
	description       *string
	disabled          *bool
	agentId           *uint
	addagentId        *uint
	clusterId         *uint
	addclusterId      *uint
	clearedFields     map[string]struct{}
	owner             *uint
	clearedowner      bool
	containers        map[uint]struct{}
	removedcontainers map[uint]struct{}
	clearedcontainers bool
	process           map[uint]struct{}
	removedprocess    map[uint]struct{}
	clearedprocess    bool
	done              bool
	oldValue          func(context.Context) (*Node, error)
	predicates        []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id uint) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetHost sets the "host" field.
func (m *NodeMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *NodeMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *NodeMutation) ResetHost() {
	m.host = nil
}

// SetIpv4 sets the "ipv4" field.
func (m *NodeMutation) SetIpv4(s string) {
	m.ipv4 = &s
}

// Ipv4 returns the value of the "ipv4" field in the mutation.
func (m *NodeMutation) Ipv4() (r string, exists bool) {
	v := m.ipv4
	if v == nil {
		return
	}
	return *v, true
}

// OldIpv4 returns the old "ipv4" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIpv4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIpv4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIpv4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpv4: %w", err)
	}
	return oldValue.Ipv4, nil
}

// ResetIpv4 resets all changes to the "ipv4" field.
func (m *NodeMutation) ResetIpv4() {
	m.ipv4 = nil
}

// SetIpv6 sets the "ipv6" field.
func (m *NodeMutation) SetIpv6(s string) {
	m.ipv6 = &s
}

// Ipv6 returns the value of the "ipv6" field in the mutation.
func (m *NodeMutation) Ipv6() (r string, exists bool) {
	v := m.ipv6
	if v == nil {
		return
	}
	return *v, true
}

// OldIpv6 returns the old "ipv6" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIpv6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIpv6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIpv6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpv6: %w", err)
	}
	return oldValue.Ipv6, nil
}

// ResetIpv6 resets all changes to the "ipv6" field.
func (m *NodeMutation) ResetIpv6() {
	m.ipv6 = nil
}

// SetPublicIpv4 sets the "public_ipv4" field.
func (m *NodeMutation) SetPublicIpv4(s string) {
	m.public_ipv4 = &s
}

// PublicIpv4 returns the value of the "public_ipv4" field in the mutation.
func (m *NodeMutation) PublicIpv4() (r string, exists bool) {
	v := m.public_ipv4
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIpv4 returns the old "public_ipv4" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPublicIpv4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicIpv4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicIpv4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIpv4: %w", err)
	}
	return oldValue.PublicIpv4, nil
}

// ResetPublicIpv4 resets all changes to the "public_ipv4" field.
func (m *NodeMutation) ResetPublicIpv4() {
	m.public_ipv4 = nil
}

// SetPublicIpv6 sets the "public_ipv6" field.
func (m *NodeMutation) SetPublicIpv6(s string) {
	m.public_ipv6 = &s
}

// PublicIpv6 returns the value of the "public_ipv6" field in the mutation.
func (m *NodeMutation) PublicIpv6() (r string, exists bool) {
	v := m.public_ipv6
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIpv6 returns the old "public_ipv6" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPublicIpv6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicIpv6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicIpv6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIpv6: %w", err)
	}
	return oldValue.PublicIpv6, nil
}

// ResetPublicIpv6 resets all changes to the "public_ipv6" field.
func (m *NodeMutation) ResetPublicIpv6() {
	m.public_ipv6 = nil
}

// SetOs sets the "os" field.
func (m *NodeMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *NodeMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *NodeMutation) ResetOs() {
	m.os = nil
}

// SetPlatform sets the "platform" field.
func (m *NodeMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *NodeMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *NodeMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformFamily sets the "platformFamily" field.
func (m *NodeMutation) SetPlatformFamily(s string) {
	m.platformFamily = &s
}

// PlatformFamily returns the value of the "platformFamily" field in the mutation.
func (m *NodeMutation) PlatformFamily() (r string, exists bool) {
	v := m.platformFamily
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformFamily returns the old "platformFamily" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPlatformFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatformFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatformFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformFamily: %w", err)
	}
	return oldValue.PlatformFamily, nil
}

// ResetPlatformFamily resets all changes to the "platformFamily" field.
func (m *NodeMutation) ResetPlatformFamily() {
	m.platformFamily = nil
}

// SetInfo sets the "info" field.
func (m *NodeMutation) SetInfo(s []string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *NodeMutation) Info() (r []string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldInfo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *NodeMutation) ResetInfo() {
	m.info = nil
}

// SetUUID sets the "uuid" field.
func (m *NodeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *NodeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *NodeMutation) ResetUUID() {
	m.uuid = nil
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
}

// SetDisabled sets the "disabled" field.
func (m *NodeMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NodeMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NodeMutation) ResetDisabled() {
	m.disabled = nil
}

// SetAgentId sets the "agentId" field.
func (m *NodeMutation) SetAgentId(u uint) {
	m.agentId = &u
	m.addagentId = nil
}

// AgentId returns the value of the "agentId" field in the mutation.
func (m *NodeMutation) AgentId() (r uint, exists bool) {
	v := m.agentId
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentId returns the old "agentId" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAgentId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentId: %w", err)
	}
	return oldValue.AgentId, nil
}

// AddAgentId adds u to the "agentId" field.
func (m *NodeMutation) AddAgentId(u uint) {
	if m.addagentId != nil {
		*m.addagentId += u
	} else {
		m.addagentId = &u
	}
}

// AddedAgentId returns the value that was added to the "agentId" field in this mutation.
func (m *NodeMutation) AddedAgentId() (r uint, exists bool) {
	v := m.addagentId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgentId resets all changes to the "agentId" field.
func (m *NodeMutation) ResetAgentId() {
	m.agentId = nil
	m.addagentId = nil
}

// SetClusterId sets the "clusterId" field.
func (m *NodeMutation) SetClusterId(u uint) {
	m.clusterId = &u
	m.addclusterId = nil
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *NodeMutation) ClusterId() (r uint, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldClusterId(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// AddClusterId adds u to the "clusterId" field.
func (m *NodeMutation) AddClusterId(u uint) {
	if m.addclusterId != nil {
		*m.addclusterId += u
	} else {
		m.addclusterId = &u
	}
}

// AddedClusterId returns the value that was added to the "clusterId" field in this mutation.
func (m *NodeMutation) AddedClusterId() (r uint, exists bool) {
	v := m.addclusterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *NodeMutation) ResetClusterId() {
	m.clusterId = nil
	m.addclusterId = nil
}

// SetOwnerID sets the "owner" edge to the Cluster entity by id.
func (m *NodeMutation) SetOwnerID(id uint) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Cluster entity.
func (m *NodeMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Cluster entity was cleared.
func (m *NodeMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NodeMutation) OwnerID() (id uint, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) OwnerIDs() (ids []uint) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NodeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddContainerIDs adds the "containers" edge to the Container entity by ids.
func (m *NodeMutation) AddContainerIDs(ids ...uint) {
	if m.containers == nil {
		m.containers = make(map[uint]struct{})
	}
	for i := range ids {
		m.containers[ids[i]] = struct{}{}
	}
}

// ClearContainers clears the "containers" edge to the Container entity.
func (m *NodeMutation) ClearContainers() {
	m.clearedcontainers = true
}

// ContainersCleared reports if the "containers" edge to the Container entity was cleared.
func (m *NodeMutation) ContainersCleared() bool {
	return m.clearedcontainers
}

// RemoveContainerIDs removes the "containers" edge to the Container entity by IDs.
func (m *NodeMutation) RemoveContainerIDs(ids ...uint) {
	if m.removedcontainers == nil {
		m.removedcontainers = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.containers, ids[i])
		m.removedcontainers[ids[i]] = struct{}{}
	}
}

// RemovedContainers returns the removed IDs of the "containers" edge to the Container entity.
func (m *NodeMutation) RemovedContainersIDs() (ids []uint) {
	for id := range m.removedcontainers {
		ids = append(ids, id)
	}
	return
}

// ContainersIDs returns the "containers" edge IDs in the mutation.
func (m *NodeMutation) ContainersIDs() (ids []uint) {
	for id := range m.containers {
		ids = append(ids, id)
	}
	return
}

// ResetContainers resets all changes to the "containers" edge.
func (m *NodeMutation) ResetContainers() {
	m.containers = nil
	m.clearedcontainers = false
	m.removedcontainers = nil
}

// AddProcesIDs adds the "process" edge to the Proces entity by ids.
func (m *NodeMutation) AddProcesIDs(ids ...uint) {
	if m.process == nil {
		m.process = make(map[uint]struct{})
	}
	for i := range ids {
		m.process[ids[i]] = struct{}{}
	}
}

// ClearProcess clears the "process" edge to the Proces entity.
func (m *NodeMutation) ClearProcess() {
	m.clearedprocess = true
}

// ProcessCleared reports if the "process" edge to the Proces entity was cleared.
func (m *NodeMutation) ProcessCleared() bool {
	return m.clearedprocess
}

// RemoveProcesIDs removes the "process" edge to the Proces entity by IDs.
func (m *NodeMutation) RemoveProcesIDs(ids ...uint) {
	if m.removedprocess == nil {
		m.removedprocess = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.process, ids[i])
		m.removedprocess[ids[i]] = struct{}{}
	}
}

// RemovedProcess returns the removed IDs of the "process" edge to the Proces entity.
func (m *NodeMutation) RemovedProcessIDs() (ids []uint) {
	for id := range m.removedprocess {
		ids = append(ids, id)
	}
	return
}

// ProcessIDs returns the "process" edge IDs in the mutation.
func (m *NodeMutation) ProcessIDs() (ids []uint) {
	for id := range m.process {
		ids = append(ids, id)
	}
	return
}

// ResetProcess resets all changes to the "process" edge.
func (m *NodeMutation) ResetProcess() {
	m.process = nil
	m.clearedprocess = false
	m.removedprocess = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.host != nil {
		fields = append(fields, node.FieldHost)
	}
	if m.ipv4 != nil {
		fields = append(fields, node.FieldIpv4)
	}
	if m.ipv6 != nil {
		fields = append(fields, node.FieldIpv6)
	}
	if m.public_ipv4 != nil {
		fields = append(fields, node.FieldPublicIpv4)
	}
	if m.public_ipv6 != nil {
		fields = append(fields, node.FieldPublicIpv6)
	}
	if m.os != nil {
		fields = append(fields, node.FieldOs)
	}
	if m.platform != nil {
		fields = append(fields, node.FieldPlatform)
	}
	if m.platformFamily != nil {
		fields = append(fields, node.FieldPlatformFamily)
	}
	if m.info != nil {
		fields = append(fields, node.FieldInfo)
	}
	if m.uuid != nil {
		fields = append(fields, node.FieldUUID)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m.disabled != nil {
		fields = append(fields, node.FieldDisabled)
	}
	if m.agentId != nil {
		fields = append(fields, node.FieldAgentId)
	}
	if m.clusterId != nil {
		fields = append(fields, node.FieldClusterId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	case node.FieldDeletedAt:
		return m.DeletedAt()
	case node.FieldHost:
		return m.Host()
	case node.FieldIpv4:
		return m.Ipv4()
	case node.FieldIpv6:
		return m.Ipv6()
	case node.FieldPublicIpv4:
		return m.PublicIpv4()
	case node.FieldPublicIpv6:
		return m.PublicIpv6()
	case node.FieldOs:
		return m.Os()
	case node.FieldPlatform:
		return m.Platform()
	case node.FieldPlatformFamily:
		return m.PlatformFamily()
	case node.FieldInfo:
		return m.Info()
	case node.FieldUUID:
		return m.UUID()
	case node.FieldDescription:
		return m.Description()
	case node.FieldDisabled:
		return m.Disabled()
	case node.FieldAgentId:
		return m.AgentId()
	case node.FieldClusterId:
		return m.ClusterId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case node.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case node.FieldHost:
		return m.OldHost(ctx)
	case node.FieldIpv4:
		return m.OldIpv4(ctx)
	case node.FieldIpv6:
		return m.OldIpv6(ctx)
	case node.FieldPublicIpv4:
		return m.OldPublicIpv4(ctx)
	case node.FieldPublicIpv6:
		return m.OldPublicIpv6(ctx)
	case node.FieldOs:
		return m.OldOs(ctx)
	case node.FieldPlatform:
		return m.OldPlatform(ctx)
	case node.FieldPlatformFamily:
		return m.OldPlatformFamily(ctx)
	case node.FieldInfo:
		return m.OldInfo(ctx)
	case node.FieldUUID:
		return m.OldUUID(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldDisabled:
		return m.OldDisabled(ctx)
	case node.FieldAgentId:
		return m.OldAgentId(ctx)
	case node.FieldClusterId:
		return m.OldClusterId(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case node.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case node.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case node.FieldIpv4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpv4(v)
		return nil
	case node.FieldIpv6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpv6(v)
		return nil
	case node.FieldPublicIpv4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIpv4(v)
		return nil
	case node.FieldPublicIpv6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIpv6(v)
		return nil
	case node.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case node.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case node.FieldPlatformFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformFamily(v)
		return nil
	case node.FieldInfo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case node.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case node.FieldAgentId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentId(v)
		return nil
	case node.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	var fields []string
	if m.addagentId != nil {
		fields = append(fields, node.FieldAgentId)
	}
	if m.addclusterId != nil {
		fields = append(fields, node.FieldClusterId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case node.FieldAgentId:
		return m.AddedAgentId()
	case node.FieldClusterId:
		return m.AddedClusterId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case node.FieldAgentId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgentId(v)
		return nil
	case node.FieldClusterId:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClusterId(v)
		return nil
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case node.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case node.FieldHost:
		m.ResetHost()
		return nil
	case node.FieldIpv4:
		m.ResetIpv4()
		return nil
	case node.FieldIpv6:
		m.ResetIpv6()
		return nil
	case node.FieldPublicIpv4:
		m.ResetPublicIpv4()
		return nil
	case node.FieldPublicIpv6:
		m.ResetPublicIpv6()
		return nil
	case node.FieldOs:
		m.ResetOs()
		return nil
	case node.FieldPlatform:
		m.ResetPlatform()
		return nil
	case node.FieldPlatformFamily:
		m.ResetPlatformFamily()
		return nil
	case node.FieldInfo:
		m.ResetInfo()
		return nil
	case node.FieldUUID:
		m.ResetUUID()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldDisabled:
		m.ResetDisabled()
		return nil
	case node.FieldAgentId:
		m.ResetAgentId()
		return nil
	case node.FieldClusterId:
		m.ResetClusterId()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, node.EdgeOwner)
	}
	if m.containers != nil {
		edges = append(edges, node.EdgeContainers)
	}
	if m.process != nil {
		edges = append(edges, node.EdgeProcess)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeContainers:
		ids := make([]ent.Value, 0, len(m.containers))
		for id := range m.containers {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeProcess:
		ids := make([]ent.Value, 0, len(m.process))
		for id := range m.process {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcontainers != nil {
		edges = append(edges, node.EdgeContainers)
	}
	if m.removedprocess != nil {
		edges = append(edges, node.EdgeProcess)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeContainers:
		ids := make([]ent.Value, 0, len(m.removedcontainers))
		for id := range m.removedcontainers {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeProcess:
		ids := make([]ent.Value, 0, len(m.removedprocess))
		for id := range m.removedprocess {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, node.EdgeOwner)
	}
	if m.clearedcontainers {
		edges = append(edges, node.EdgeContainers)
	}
	if m.clearedprocess {
		edges = append(edges, node.EdgeProcess)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeOwner:
		return m.clearedowner
	case node.EdgeContainers:
		return m.clearedcontainers
	case node.EdgeProcess:
		return m.clearedprocess
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ResetOwner()
		return nil
	case node.EdgeContainers:
		m.ResetContainers()
		return nil
	case node.EdgeProcess:
		m.ResetProcess()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// ProcesMutation represents an operation that mutates the Proces nodes in the graph.
type ProcesMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	pId                      *int32
	addpId                   *int32
	cmd                      *string
	info                     *[]string
	clusterId                *string
	nodeId                   *string
	containerId              *string
	clearedFields            map[string]struct{}
	node_process             *uint
	clearednode_process      bool
	container_process        *uint
	clearedcontainer_process bool
	done                     bool
	oldValue                 func(context.Context) (*Proces, error)
	predicates               []predicate.Proces
}

var _ ent.Mutation = (*ProcesMutation)(nil)

// procesOption allows management of the mutation configuration using functional options.
type procesOption func(*ProcesMutation)

// newProcesMutation creates new mutation for the Proces entity.
func newProcesMutation(c config, op Op, opts ...procesOption) *ProcesMutation {
	m := &ProcesMutation{
		config:        c,
		op:            op,
		typ:           TypeProces,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcesID sets the ID field of the mutation.
func withProcesID(id uint) procesOption {
	return func(m *ProcesMutation) {
		var (
			err   error
			once  sync.Once
			value *Proces
		)
		m.oldValue = func(ctx context.Context) (*Proces, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proces.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProces sets the old Proces of the mutation.
func withProces(node *Proces) procesOption {
	return func(m *ProcesMutation) {
		m.oldValue = func(context.Context) (*Proces, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Proces entities.
func (m *ProcesMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcesMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProcesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProcesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProcesMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ProcesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcesMutation) ResetName() {
	m.name = nil
}

// SetPId sets the "pId" field.
func (m *ProcesMutation) SetPId(i int32) {
	m.pId = &i
	m.addpId = nil
}

// PId returns the value of the "pId" field in the mutation.
func (m *ProcesMutation) PId() (r int32, exists bool) {
	v := m.pId
	if v == nil {
		return
	}
	return *v, true
}

// OldPId returns the old "pId" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldPId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPId: %w", err)
	}
	return oldValue.PId, nil
}

// AddPId adds i to the "pId" field.
func (m *ProcesMutation) AddPId(i int32) {
	if m.addpId != nil {
		*m.addpId += i
	} else {
		m.addpId = &i
	}
}

// AddedPId returns the value that was added to the "pId" field in this mutation.
func (m *ProcesMutation) AddedPId() (r int32, exists bool) {
	v := m.addpId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPId resets all changes to the "pId" field.
func (m *ProcesMutation) ResetPId() {
	m.pId = nil
	m.addpId = nil
}

// SetCmd sets the "cmd" field.
func (m *ProcesMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *ProcesMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ResetCmd resets all changes to the "cmd" field.
func (m *ProcesMutation) ResetCmd() {
	m.cmd = nil
}

// SetInfo sets the "info" field.
func (m *ProcesMutation) SetInfo(s []string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *ProcesMutation) Info() (r []string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldInfo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *ProcesMutation) ResetInfo() {
	m.info = nil
}

// SetClusterId sets the "clusterId" field.
func (m *ProcesMutation) SetClusterId(s string) {
	m.clusterId = &s
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *ProcesMutation) ClusterId() (r string, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldClusterId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *ProcesMutation) ResetClusterId() {
	m.clusterId = nil
}

// SetNodeId sets the "nodeId" field.
func (m *ProcesMutation) SetNodeId(s string) {
	m.nodeId = &s
}

// NodeId returns the value of the "nodeId" field in the mutation.
func (m *ProcesMutation) NodeId() (r string, exists bool) {
	v := m.nodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeId returns the old "nodeId" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldNodeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeId: %w", err)
	}
	return oldValue.NodeId, nil
}

// ResetNodeId resets all changes to the "nodeId" field.
func (m *ProcesMutation) ResetNodeId() {
	m.nodeId = nil
}

// SetContainerId sets the "containerId" field.
func (m *ProcesMutation) SetContainerId(s string) {
	m.containerId = &s
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *ProcesMutation) ContainerId() (r string, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the Proces entity.
// If the Proces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcesMutation) OldContainerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *ProcesMutation) ResetContainerId() {
	m.containerId = nil
}

// SetNodeProcessID sets the "node_process" edge to the Node entity by id.
func (m *ProcesMutation) SetNodeProcessID(id uint) {
	m.node_process = &id
}

// ClearNodeProcess clears the "node_process" edge to the Node entity.
func (m *ProcesMutation) ClearNodeProcess() {
	m.clearednode_process = true
}

// NodeProcessCleared reports if the "node_process" edge to the Node entity was cleared.
func (m *ProcesMutation) NodeProcessCleared() bool {
	return m.clearednode_process
}

// NodeProcessID returns the "node_process" edge ID in the mutation.
func (m *ProcesMutation) NodeProcessID() (id uint, exists bool) {
	if m.node_process != nil {
		return *m.node_process, true
	}
	return
}

// NodeProcessIDs returns the "node_process" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeProcessID instead. It exists only for internal usage by the builders.
func (m *ProcesMutation) NodeProcessIDs() (ids []uint) {
	if id := m.node_process; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodeProcess resets all changes to the "node_process" edge.
func (m *ProcesMutation) ResetNodeProcess() {
	m.node_process = nil
	m.clearednode_process = false
}

// SetContainerProcessID sets the "container_process" edge to the Container entity by id.
func (m *ProcesMutation) SetContainerProcessID(id uint) {
	m.container_process = &id
}

// ClearContainerProcess clears the "container_process" edge to the Container entity.
func (m *ProcesMutation) ClearContainerProcess() {
	m.clearedcontainer_process = true
}

// ContainerProcessCleared reports if the "container_process" edge to the Container entity was cleared.
func (m *ProcesMutation) ContainerProcessCleared() bool {
	return m.clearedcontainer_process
}

// ContainerProcessID returns the "container_process" edge ID in the mutation.
func (m *ProcesMutation) ContainerProcessID() (id uint, exists bool) {
	if m.container_process != nil {
		return *m.container_process, true
	}
	return
}

// ContainerProcessIDs returns the "container_process" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContainerProcessID instead. It exists only for internal usage by the builders.
func (m *ProcesMutation) ContainerProcessIDs() (ids []uint) {
	if id := m.container_process; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContainerProcess resets all changes to the "container_process" edge.
func (m *ProcesMutation) ResetContainerProcess() {
	m.container_process = nil
	m.clearedcontainer_process = false
}

// Where appends a list predicates to the ProcesMutation builder.
func (m *ProcesMutation) Where(ps ...predicate.Proces) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Proces).
func (m *ProcesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, proces.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proces.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, proces.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, proces.FieldName)
	}
	if m.pId != nil {
		fields = append(fields, proces.FieldPId)
	}
	if m.cmd != nil {
		fields = append(fields, proces.FieldCmd)
	}
	if m.info != nil {
		fields = append(fields, proces.FieldInfo)
	}
	if m.clusterId != nil {
		fields = append(fields, proces.FieldClusterId)
	}
	if m.nodeId != nil {
		fields = append(fields, proces.FieldNodeId)
	}
	if m.containerId != nil {
		fields = append(fields, proces.FieldContainerId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proces.FieldCreatedAt:
		return m.CreatedAt()
	case proces.FieldUpdatedAt:
		return m.UpdatedAt()
	case proces.FieldDeletedAt:
		return m.DeletedAt()
	case proces.FieldName:
		return m.Name()
	case proces.FieldPId:
		return m.PId()
	case proces.FieldCmd:
		return m.Cmd()
	case proces.FieldInfo:
		return m.Info()
	case proces.FieldClusterId:
		return m.ClusterId()
	case proces.FieldNodeId:
		return m.NodeId()
	case proces.FieldContainerId:
		return m.ContainerId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proces.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proces.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proces.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case proces.FieldName:
		return m.OldName(ctx)
	case proces.FieldPId:
		return m.OldPId(ctx)
	case proces.FieldCmd:
		return m.OldCmd(ctx)
	case proces.FieldInfo:
		return m.OldInfo(ctx)
	case proces.FieldClusterId:
		return m.OldClusterId(ctx)
	case proces.FieldNodeId:
		return m.OldNodeId(ctx)
	case proces.FieldContainerId:
		return m.OldContainerId(ctx)
	}
	return nil, fmt.Errorf("unknown Proces field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proces.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proces.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proces.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case proces.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proces.FieldPId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPId(v)
		return nil
	case proces.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case proces.FieldInfo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case proces.FieldClusterId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	case proces.FieldNodeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeId(v)
		return nil
	case proces.FieldContainerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	}
	return fmt.Errorf("unknown Proces field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcesMutation) AddedFields() []string {
	var fields []string
	if m.addpId != nil {
		fields = append(fields, proces.FieldPId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proces.FieldPId:
		return m.AddedPId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proces.FieldPId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPId(v)
		return nil
	}
	return fmt.Errorf("unknown Proces numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Proces nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcesMutation) ResetField(name string) error {
	switch name {
	case proces.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proces.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proces.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case proces.FieldName:
		m.ResetName()
		return nil
	case proces.FieldPId:
		m.ResetPId()
		return nil
	case proces.FieldCmd:
		m.ResetCmd()
		return nil
	case proces.FieldInfo:
		m.ResetInfo()
		return nil
	case proces.FieldClusterId:
		m.ResetClusterId()
		return nil
	case proces.FieldNodeId:
		m.ResetNodeId()
		return nil
	case proces.FieldContainerId:
		m.ResetContainerId()
		return nil
	}
	return fmt.Errorf("unknown Proces field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.node_process != nil {
		edges = append(edges, proces.EdgeNodeProcess)
	}
	if m.container_process != nil {
		edges = append(edges, proces.EdgeContainerProcess)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proces.EdgeNodeProcess:
		if id := m.node_process; id != nil {
			return []ent.Value{*id}
		}
	case proces.EdgeContainerProcess:
		if id := m.container_process; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednode_process {
		edges = append(edges, proces.EdgeNodeProcess)
	}
	if m.clearedcontainer_process {
		edges = append(edges, proces.EdgeContainerProcess)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcesMutation) EdgeCleared(name string) bool {
	switch name {
	case proces.EdgeNodeProcess:
		return m.clearednode_process
	case proces.EdgeContainerProcess:
		return m.clearedcontainer_process
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcesMutation) ClearEdge(name string) error {
	switch name {
	case proces.EdgeNodeProcess:
		m.ClearNodeProcess()
		return nil
	case proces.EdgeContainerProcess:
		m.ClearContainerProcess()
		return nil
	}
	return fmt.Errorf("unknown Proces unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcesMutation) ResetEdge(name string) error {
	switch name {
	case proces.EdgeNodeProcess:
		m.ResetNodeProcess()
		return nil
	case proces.EdgeContainerProcess:
		m.ResetContainerProcess()
		return nil
	}
	return fmt.Errorf("unknown Proces edge %s", name)
}

// ProcessMutation represents an operation that mutates the Process nodes in the graph.
type ProcessMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	pId           *int32
	addpId        *int32
	cmd           *string
	info          *[]string
	clusterId     *string
	nodeId        *string
	containerId   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Process, error)
	predicates    []predicate.Process
}

var _ ent.Mutation = (*ProcessMutation)(nil)

// processOption allows management of the mutation configuration using functional options.
type processOption func(*ProcessMutation)

// newProcessMutation creates new mutation for the Process entity.
func newProcessMutation(c config, op Op, opts ...processOption) *ProcessMutation {
	m := &ProcessMutation{
		config:        c,
		op:            op,
		typ:           TypeProcess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessID sets the ID field of the mutation.
func withProcessID(id uint) processOption {
	return func(m *ProcessMutation) {
		var (
			err   error
			once  sync.Once
			value *Process
		)
		m.oldValue = func(ctx context.Context) (*Process, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Process.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcess sets the old Process of the mutation.
func withProcess(node *Process) processOption {
	return func(m *ProcessMutation) {
		m.oldValue = func(context.Context) (*Process, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Process entities.
func (m *ProcessMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProcessMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProcessMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProcessMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ProcessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcessMutation) ResetName() {
	m.name = nil
}

// SetPId sets the "pId" field.
func (m *ProcessMutation) SetPId(i int32) {
	m.pId = &i
	m.addpId = nil
}

// PId returns the value of the "pId" field in the mutation.
func (m *ProcessMutation) PId() (r int32, exists bool) {
	v := m.pId
	if v == nil {
		return
	}
	return *v, true
}

// OldPId returns the old "pId" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldPId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPId: %w", err)
	}
	return oldValue.PId, nil
}

// AddPId adds i to the "pId" field.
func (m *ProcessMutation) AddPId(i int32) {
	if m.addpId != nil {
		*m.addpId += i
	} else {
		m.addpId = &i
	}
}

// AddedPId returns the value that was added to the "pId" field in this mutation.
func (m *ProcessMutation) AddedPId() (r int32, exists bool) {
	v := m.addpId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPId resets all changes to the "pId" field.
func (m *ProcessMutation) ResetPId() {
	m.pId = nil
	m.addpId = nil
}

// SetCmd sets the "cmd" field.
func (m *ProcessMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *ProcessMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ResetCmd resets all changes to the "cmd" field.
func (m *ProcessMutation) ResetCmd() {
	m.cmd = nil
}

// SetInfo sets the "info" field.
func (m *ProcessMutation) SetInfo(s []string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *ProcessMutation) Info() (r []string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldInfo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *ProcessMutation) ResetInfo() {
	m.info = nil
}

// SetClusterId sets the "clusterId" field.
func (m *ProcessMutation) SetClusterId(s string) {
	m.clusterId = &s
}

// ClusterId returns the value of the "clusterId" field in the mutation.
func (m *ProcessMutation) ClusterId() (r string, exists bool) {
	v := m.clusterId
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterId returns the old "clusterId" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldClusterId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClusterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClusterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterId: %w", err)
	}
	return oldValue.ClusterId, nil
}

// ResetClusterId resets all changes to the "clusterId" field.
func (m *ProcessMutation) ResetClusterId() {
	m.clusterId = nil
}

// SetNodeId sets the "nodeId" field.
func (m *ProcessMutation) SetNodeId(s string) {
	m.nodeId = &s
}

// NodeId returns the value of the "nodeId" field in the mutation.
func (m *ProcessMutation) NodeId() (r string, exists bool) {
	v := m.nodeId
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeId returns the old "nodeId" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldNodeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeId: %w", err)
	}
	return oldValue.NodeId, nil
}

// ResetNodeId resets all changes to the "nodeId" field.
func (m *ProcessMutation) ResetNodeId() {
	m.nodeId = nil
}

// SetContainerId sets the "containerId" field.
func (m *ProcessMutation) SetContainerId(s string) {
	m.containerId = &s
}

// ContainerId returns the value of the "containerId" field in the mutation.
func (m *ProcessMutation) ContainerId() (r string, exists bool) {
	v := m.containerId
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerId returns the old "containerId" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldContainerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContainerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContainerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerId: %w", err)
	}
	return oldValue.ContainerId, nil
}

// ResetContainerId resets all changes to the "containerId" field.
func (m *ProcessMutation) ResetContainerId() {
	m.containerId = nil
}

// Where appends a list predicates to the ProcessMutation builder.
func (m *ProcessMutation) Where(ps ...predicate.Process) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcessMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Process).
func (m *ProcessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, process.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, process.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, process.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, process.FieldName)
	}
	if m.pId != nil {
		fields = append(fields, process.FieldPId)
	}
	if m.cmd != nil {
		fields = append(fields, process.FieldCmd)
	}
	if m.info != nil {
		fields = append(fields, process.FieldInfo)
	}
	if m.clusterId != nil {
		fields = append(fields, process.FieldClusterId)
	}
	if m.nodeId != nil {
		fields = append(fields, process.FieldNodeId)
	}
	if m.containerId != nil {
		fields = append(fields, process.FieldContainerId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case process.FieldCreatedAt:
		return m.CreatedAt()
	case process.FieldUpdatedAt:
		return m.UpdatedAt()
	case process.FieldDeletedAt:
		return m.DeletedAt()
	case process.FieldName:
		return m.Name()
	case process.FieldPId:
		return m.PId()
	case process.FieldCmd:
		return m.Cmd()
	case process.FieldInfo:
		return m.Info()
	case process.FieldClusterId:
		return m.ClusterId()
	case process.FieldNodeId:
		return m.NodeId()
	case process.FieldContainerId:
		return m.ContainerId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case process.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case process.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case process.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case process.FieldName:
		return m.OldName(ctx)
	case process.FieldPId:
		return m.OldPId(ctx)
	case process.FieldCmd:
		return m.OldCmd(ctx)
	case process.FieldInfo:
		return m.OldInfo(ctx)
	case process.FieldClusterId:
		return m.OldClusterId(ctx)
	case process.FieldNodeId:
		return m.OldNodeId(ctx)
	case process.FieldContainerId:
		return m.OldContainerId(ctx)
	}
	return nil, fmt.Errorf("unknown Process field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case process.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case process.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case process.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case process.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case process.FieldPId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPId(v)
		return nil
	case process.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case process.FieldInfo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case process.FieldClusterId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterId(v)
		return nil
	case process.FieldNodeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeId(v)
		return nil
	case process.FieldContainerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerId(v)
		return nil
	}
	return fmt.Errorf("unknown Process field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessMutation) AddedFields() []string {
	var fields []string
	if m.addpId != nil {
		fields = append(fields, process.FieldPId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case process.FieldPId:
		return m.AddedPId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case process.FieldPId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPId(v)
		return nil
	}
	return fmt.Errorf("unknown Process numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Process nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessMutation) ResetField(name string) error {
	switch name {
	case process.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case process.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case process.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case process.FieldName:
		m.ResetName()
		return nil
	case process.FieldPId:
		m.ResetPId()
		return nil
	case process.FieldCmd:
		m.ResetCmd()
		return nil
	case process.FieldInfo:
		m.ResetInfo()
		return nil
	case process.FieldClusterId:
		m.ResetClusterId()
		return nil
	case process.FieldNodeId:
		m.ResetNodeId()
		return nil
	case process.FieldContainerId:
		m.ResetContainerId()
		return nil
	}
	return fmt.Errorf("unknown Process field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Process unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Process edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldDeletedAt:
		return m.DeletedAt()
	case setting.FieldName:
		return m.Name()
	case setting.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}
